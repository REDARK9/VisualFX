<html><head><style>body {
   color: black;
}
</style></head><body><p>⟶ E-BOOK</p>
<p><img src="_page_0_Picture_1.jpeg" alt=""></p>
<h1 id="-the-definitive-guide-to-creating-advanced-visual-effects-in-unity-"><strong>The definitive guide to creating advanced visual effects in Unity</strong></h1>
<p><img src="_page_0_Picture_3.jpeg" alt=""></p>
<p><img src="_page_0_Picture_4.jpeg" alt=""></p>
<h2 id="-contents-"><strong>Contents</strong></h2>
<table>
<thead>
<tr>
<th>Introduction 7</th>
</tr>
</thead>
<tbody>
<tr>
<td>Contributors 8</td>
</tr>
<tr>
<td>Main author 8</td>
</tr>
<tr>
<td>Unity contributors 8</td>
</tr>
<tr>
<td>External contributors 8</td>
</tr>
<tr>
<td>Getting started with real-time VFX 9</td>
</tr>
<tr>
<td>Visual workflow 11</td>
</tr>
<tr>
<td>Core graphics packages 12</td>
</tr>
<tr>
<td>Additional sample content 12</td>
</tr>
<tr>
<td>The Built-In Particle System 13</td>
</tr>
<tr>
<td>Introduction to the VFX Graph 16</td>
</tr>
<tr>
<td>The VFX Graph Asset and component 17</td>
</tr>
<tr>
<td>The VFX Graph window 19</td>
</tr>
<tr>
<td>Graph logic 21</td>
</tr>
<tr>
<td>Systems, Contexts, and Blocks 22</td>
</tr>
<tr>
<td>Properties and Operators 27</td>
</tr>
<tr>
<td>The Blackboard 30</td>
</tr>
<tr>
<td>Group Nodes and Sticky Notes 32</td>
</tr>
<tr>
<td>Subgraphs 33</td>
</tr>
<tr>
<td>Attributes 35</td>
</tr>
<tr>
<td>Blackboard Attributes 39</td>
</tr>
<tr>
<td>Events 42</td>
</tr>
<tr>
<td>Event Attributes 44</td>
</tr>
<tr>
<td>UI improvements in Unity 6 45</td>
</tr>
<tr>
<td>Node search 45</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Activation ports 46</th>
</tr>
</thead>
<tbody>
<tr>
<td>New VFX Toolbar 47</td>
</tr>
<tr>
<td>Keyboard shortcuts 47</td>
</tr>
<tr>
<td>Exploring VFX sample content 48</td>
</tr>
<tr>
<td>More resources 55</td>
</tr>
<tr>
<td>Additional references 55</td>
</tr>
<tr>
<td>Visual effects by example 56</td>
</tr>
<tr>
<td>VFX Graph Learning Templates 56</td>
</tr>
<tr>
<td>Visualizing gizmos 57</td>
</tr>
<tr>
<td>Graph fundamentals 58</td>
</tr>
<tr>
<td>Contexts &amp; Data Flow 58</td>
</tr>
<tr>
<td>Spawn Context 59</td>
</tr>
<tr>
<td>Capacity Count 59</td>
</tr>
<tr>
<td>Multiple Outputs 60</td>
</tr>
<tr>
<td>Bounds 61</td>
</tr>
<tr>
<td>Particle orientation and rotation 62</td>
</tr>
<tr>
<td>Texturing and flipbooks 63</td>
</tr>
<tr>
<td>Particle pivots 65</td>
</tr>
<tr>
<td>Mesh and texture sampling 66</td>
</tr>
<tr>
<td>Collisions and interactivity 69</td>
</tr>
<tr>
<td>Decal particles 72</td>
</tr>
<tr>
<td>Particle Strips 73</td>
</tr>
<tr>
<td>The VFX Graph Samples (HDRP) 79</td>
</tr>
<tr>
<td>Smoke Portal 80</td>
</tr>
<tr>
<td>Six-way lighting for real-time smoke 84</td>
</tr>
<tr>
<td>GooBall 87</td>
</tr>
<tr>
<td>Physics-based effects 92</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>The Ribbon Pack 95</th>
</tr>
</thead>
<tbody>
<tr>
<td>Meteorite sample 98</td>
</tr>
<tr>
<td>Mesh sampling effects 102</td>
</tr>
<tr>
<td>Skinned Mesh sampling 105</td>
</tr>
<tr>
<td>More examples 107</td>
</tr>
<tr>
<td>Render pipelines and VFX Graph 108</td>
</tr>
<tr>
<td>VFX Graph for URP 109</td>
</tr>
<tr>
<td>Lit output 109</td>
</tr>
<tr>
<td>2D Renderer and Shader Graph support 110</td>
</tr>
<tr>
<td>Decals 111</td>
</tr>
<tr>
<td>Six-way smoke lighting 111</td>
</tr>
<tr>
<td>Motion vectors 111</td>
</tr>
<tr>
<td>Camera buffer 111</td>
</tr>
<tr>
<td>VFX Graph for HDRP 112</td>
</tr>
<tr>
<td>Ray tracing support 112</td>
</tr>
<tr>
<td>Volumetric Fog output 113</td>
</tr>
<tr>
<td>Shader Graph integration 114</td>
</tr>
<tr>
<td>Built-in Outputs 114</td>
</tr>
<tr>
<td>Shader effects 115</td>
</tr>
<tr>
<td>Shader Graph and VFX Graph 122</td>
</tr>
<tr>
<td>Shader Graph Feature Examples 123</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Interactivity 124</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event Binders 124</td>
</tr>
<tr>
<td>OnPlay and OnStop Events 125</td>
</tr>
<tr>
<td>Mouse Event Binder 126</td>
</tr>
<tr>
<td>Rigidbody Collision Event Binders 127</td>
</tr>
<tr>
<td>Trigger Event Binder 128</td>
</tr>
<tr>
<td>Visibility Event Binder 129</td>
</tr>
<tr>
<td>Timeline 130</td>
</tr>
<tr>
<td>Event Attributes 132</td>
</tr>
<tr>
<td>Property Binder 133</td>
</tr>
<tr>
<td>Output Events 136</td>
</tr>
<tr>
<td>Pipeline tools 139</td>
</tr>
<tr>
<td>Point Caches 139</td>
</tr>
<tr>
<td>Point Cache Bake Tool 140</td>
</tr>
<tr>
<td>Using Point Caches 141</td>
</tr>
<tr>
<td>Signed Distance Fields 142</td>
</tr>
<tr>
<td>Using SDFs 142</td>
</tr>
<tr>
<td>SDF Bake Tool 143</td>
</tr>
<tr>
<td>Vector Fields 144</td>
</tr>
<tr>
<td>TFlow (Asset Store) 145</td>
</tr>
<tr>
<td>VFXToolbox 145</td>
</tr>
<tr>
<td>Image Sequencer 145</td>
</tr>
<tr>
<td>Digital Content Creation tools 146</td>
</tr>
<tr>
<td>SideFX Houdini 146</td>
</tr>
<tr>
<td>Autodesk Maya 146</td>
</tr>
<tr>
<td>Blender 147</td>
</tr>
<tr>
<td>Adobe Photoshop 147</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimization 148</th>
</tr>
</thead>
<tbody>
<tr>
<td>Profiling and Debug panels in VFX Graph 149</td>
</tr>
<tr>
<td>Graph Debug Information panel 149</td>
</tr>
<tr>
<td>Particle System Info panel 150</td>
</tr>
<tr>
<td>Context Debug panels 150</td>
</tr>
<tr>
<td>The Unity Profiler and Frame Debugger 151</td>
</tr>
<tr>
<td>VFX Control Debug modes 153</td>
</tr>
<tr>
<td>Bounds 155</td>
</tr>
<tr>
<td>Mesh LOD 156</td>
</tr>
<tr>
<td>Mesh Count 158</td>
</tr>
<tr>
<td>Advanced features 160</td>
</tr>
<tr>
<td>Graphics Buffer support 160</td>
</tr>
<tr>
<td>Custom HLSL 162</td>
</tr>
<tr>
<td>Additional resources 164</td>
</tr>
<tr>
<td>Video tutorials 165</td>
</tr>
<tr>
<td>VFX projects on GitHub 166</td>
</tr>
</tbody>
</table>
<h2 id="-span-id-page-6-0-span-introduction"><span id="page-6-0"></span>Introduction</h2>
<p>Whether you plan on shooting fireballs from your fingertips or traveling through a wormhole, visual effects (VFX) in a game make the impossible, well, possible. Not only do they enhance the atmosphere and help tell the story of your game, visual effects bring imagined worlds to life with details that can truly captivate your players.</p>
<p>Unity is pushing the boundaries of real-time graphics with tools such as the VFX Graph. This node-based editor enables technical and VFX artists to design dynamic visual effects – from simple common particle behaviors to complex simulations involving particles, lines, ribbons, trails, meshes, and more.</p>
<p>Our comprehensive guide is intended for artists and creators looking to incorporate the VFX Graph into their game applications. It provides specific instructions on how to use the VFX Graph and its related tools to build real-time visual effects in Unity.</p>
<p>Taking into account experiences of solo developers and those on hundred-person teams, this guide is filled with many examples to make our AAA-quality tools more accessible. This way, everyone can find themselves at the fun part of game design.</p>
<p><strong>Important note</strong>: This revised edition includes new features and quality of life improvements available with Unity 6 and above. Please ensure that you install Unity 6 from the Unity Hub to follow along with this guide. Also note that the naming convention for Unity releases has changed from Unity 6 and for future releases. Read more about <a href="https://discussions.unity.com/t/unity-6-new-naming-convention/942214">the new naming standard in</a>  <a href="https://discussions.unity.com/t/unity-6-new-naming-convention/942214">this Discussions post</a>.</p>
<p><span id="page-7-0"></span><img src="_page_7_Picture_1.jpeg" alt=""></p>
<p>The Smoke Portal from the VFX Graph Samples</p>
<h3 id="contributors">Contributors</h3>
<h4 id="-main-author-"><strong>Main author</strong></h4>
<p>Wilmer Lin is a 3D and visual effects artist with over 15 years of industry experience in film and television, now working as an independent game developer and educator. Wilmer&#39;s feature credits include <em>X-Men: Days of Future Past</em>, <em>The Incredible Hulk</em>, and <em>The Chronicles of Narnia: The Lion, the Witch, and the Wardrobe</em>.</p>
<h4 id="-unity-contributors-"><strong>Unity contributors</strong></h4>
<p>Mathieu Muller, lead product manager for graphics Vlad Neykov, director, software engineering, quality Orson Favrel, technical artist (creator of many of the new samples used in the book) Julien Fryer, graphics engineer Fred Moreau, technical product manager</p>
<h4 id="-external-contributors-"><strong>External contributors</strong></h4>
<p>Marie Guffroy, technical artist Thomas Iché, VFX artist and specialist</p>
<h2 id="-span-id-page-8-0-span-getting-started-with-real-time-vfx"><span id="page-8-0"></span>Getting started with real-time VFX</h2>
<p>Today&#39;s gamers crave deeply immersive experiences. As hardware advancements push the limits of what mobile and console platforms can do, what used to be available only for creating Hollywood blockbusters can now be attained in real-time.</p>
<p><img src="_page_8_Picture_2.jpeg" alt=""></p>
<p>VFX Graph examples</p>
<p><img src="_page_9_Picture_0.jpeg" alt=""></p>
<p>Visual effects in games continue to have their moment as both interest and investment in advanced graphics trend upward. After all, gameplay effects transport your players into the action.</p>
<p>It&#39;s difficult to imagine a fantasy role-playing game (RPG) without characters casting magic, or a hack-and-slash brawler without glowing weapon contrails. When race cars plow the asphalt, we expect that they kick up a cloud of dust in their wake.</p>
<p>Not even your environments are the same without visual effects. If you&#39;re telling a film noir detective story, you&#39;ll likely cloak your cityscape in rain and fog. But if your characters go on a quest through the wilderness, you might make your foliage and vegetation sway in the wind, reacting to their every move.</p>
<p><img src="_page_9_Picture_5.jpeg" alt=""></p>
<p><em><a href="https://playvrising.com/">V Rising</a></em> by Stunlock Studios is a game made with the High Definition Render Pipeline and VFX Graph.</p>
<p>Visual effects uniquely enhance the gaming experience. However, creating them requires you to don the mantle of a multidisciplinary artist who can manipulate shape, color, and timing.</p>
<p>That&#39;s where the VFX Graph comes in. This sophisticated tool is equipped with workflows that reflect those of motion picture VFX – except working at 30, 60, or more frames per second (fps).</p>
<p><span id="page-10-0"></span><img src="_page_10_Picture_1.jpeg" alt=""></p>
<p>Image from a project in development by <a href="https://twitter.com/Sakura_Rabbiter">Sakura Rabbit</a>, made with Unity&#39;s VFX tools</p>
<h2 id="visual-workflow">Visual workflow</h2>
<p>For complex, AAA-level visual effects on high-end platforms, use the VFX Graph to create GPU-accelerated particles in an intuitive, node-based interface.</p>
<p>Leverage the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/GettingStarted.html">VFX Graph</a> to:</p>
<ul>
<li>Create one or multiple particle systems</li>
<li>Add static meshes and control shader properties</li>
<li>Create events via C# or <a href="https://docs.unity3d.com/Packages/com.unity.timeline@latest/index.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Timeline</a> to turn parts of your effects on and off</li>
<li>Extend the library of features by creating subgraphs of commonly used node combinations</li>
<li>Preview changes at various rates and/or perform step-by-step simulation</li>
</ul>
<p>The VFX Graph works with the <strong><a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/urp-introduction.html">Universal Render Pipeline</a></strong> (URP)* and the <strong><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">High Definition</a>  <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">Render Pipeline</a></strong> (HDRP). It also adds support for the <strong>Lit</strong> outputs and <strong>2D Renderer</strong> available with URP. Check the VFX Graph feature comparison for all render pipelines <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines-feature-comparison.html">here</a>, and read more about the VFX Graph&#39;s compatibility in the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/System-Requirements.html">documentation.</a></p>
<p>The VFX Graph requires compute shader support to maintain compatibility with your device. Supported devices include:</p>
<ul>
<li>macOS and iOS platforms using <a href="https://developer.apple.com/metal/">Metal graphics</a> API</li>
<li>Linux and Windows platforms with <a href="https://www.khronos.org/vulkan/">Vulkan</a> or <a href="https://www.khronos.org/registry/OpenGL-Refpages/es3/">GLES3</a> APIs</li>
<li>Android for a subset of high-end compute capable devices (only with URP)</li>
</ul>
<p><span id="page-11-0"></span><img src="_page_11_Picture_0.jpeg" alt=""></p>
<h3 id="core-graphics-packages">Core graphics packages</h3>
<p>When you install the latest release of Unity, the most recent packages for URP, HDRP, Shader Graph, VFX Graph, and more, are included. Core graphics packages are now embedded within the main Unity installer to ensure that your project is always running on the latest, verified graphics code.</p>
<p>For details, see <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/GettingStarted.html">Getting started with VFX Graph</a>.</p>
<table>
<thead>
<tr>
<th>00</th>
<th></th>
<th>Package Manager</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ロ Package Manager</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>十 ▼ Sort: Name (asc) ▼</td>
<td>Filters ▼ Clear Filters</td>
<td></td>
<td></td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>In Project<br>G Updates</td>
<td>Q Search Unity Registry<br>Unity Ul</td>
<td>2.0.0 ©</td>
<td>Visual Effect Graph<br>17.0.3 · June 17, 2024   Release<br>From Unity Registry by Unity Technologies Inc.</td>
<td>Remove</td>
<td></td>
</tr>
<tr>
<td>H Unity Registry</td>
<td>Universal RP</td>
<td>17.0.3 €</td>
<td>com.unity.visualeffectgraph</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C My Assets</td>
<td>User Generated Content</td>
<td>3.0.1</td>
<td>Documentation Changelog Licenses</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Built-in</td>
<td>User Generated Content Bridge<br>User Reporting</td>
<td>3.0.0<br>2.0.11</td>
<td>Description Version History Dependencies Samples</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Services<br>Version Control<br>Visual Effect Graph<br>Visual Scripting</td>
<td>2.4.3 G<br>17.0.3 €</td>
<td>VisualEffectGraph Additions 26.46 MB O</td>
<td>Reimport</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>1.9.4 (-)</td>
<td>Additional Assets for use with Visual Effect Graph<br>OutputEvent Helpers 34.67 KB C<br>Reimport</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Visual Studio Editor</td>
<td>2.0.22 @</td>
<td></td>
<td>Import Samples</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Vivox</td>
<td>16.3.0</td>
<td>Additional Helper Scripts that intercept Output Events and interact with<br>Game Objects<br>Learning Templates 31.32 MB C<br>Additional sample, composed of VFX Graph assets that explain and<br>illustrate behaviors and VFX Graph concepts and features</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>WebGL Publisher</td>
<td>4.2.3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Hands</td>
<td>1.4.1</td>
<td></td>
<td>Reimport</td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Interaction Toolkit</td>
<td>3.0.4</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Plugin Management</td>
<td>4.4.1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>TiunDI Diguar<br>Last update Jun 27, 23:33</td>
<td>299<br>C</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Install sample content from the Package Manager.</p>
<h4 id="-additional-sample-content-"><strong>Additional sample content</strong></h4>
<p>If you&#39;re new to the VFX Graph, consider installing the <strong>Samples</strong> in the <strong>Package Manager</strong>. These contain some basic examples for you to explore:</p>
<p>— The new <strong>Learning Templates:</strong> The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-learningTemplates.html">Learning Templates</a> sample is a collection of VFX assets designed to help you learn about VFX Graph concepts and features. It&#39;s compatible with both URP and HDRP render pipelines.</p>
<p><img src="_page_11_Picture_10.jpeg" alt=""></p>
<p>The new Learning Templates sample showcases different VFX Graph features.</p>
<p><span id="page-12-0"></span>— The <strong>Visual Effect Graph Additions</strong>: <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-content.html#visual-effect-graph-additions">This includes</a> example prefabs of fire, smoke, sparks, and electricity. Each sample shows a stripped down effect to illustrate fundamental graph logic and construction. Just drag and drop one of the sample <strong>Prefabs</strong> into the <strong>Hierarchy</strong> to see them in action.</p>
<p><img src="_page_12_Picture_3.jpeg" alt=""></p>
<p>Samples from the Visual Effect Graph Additions package</p>
<h3 id="the-built-in-particle-system">The Built-In Particle System</h3>
<p>If your target platform does not meet the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/System-Requirements.html">minimum system requirements</a> for the VFX Graph, the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/ParticleSystem.html">Built-In Particle System</a> is another option for creating real-time effects in Unity. Access the Built-In Particle System by selecting <strong>GameObject &gt; Effects &gt; Particle System</strong>.</p>
<p>Like the VFX Graph, the Built-In Particle System allows you to create a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/ParticleSystemModules.html">variety of effects</a> such as fire, explosions, smoke, and magic spells. It remains a valuable tool for real-time effects, even though it renders fewer particles than the VFX Graph.</p>
<p>The primary distinction between the VFX Graph and the Built-In Particle System lies in their hardware. The Built-In Particle System is simulated on the CPU, whereas the VFX Graph moves many of the calculations to compute shaders, which run on the GPU.</p>
<p>The VFX Graph has the advantage of simulating millions of particles, but there&#39;s a caveat; being simulated on the GPU means that it&#39;s computationally nontrivial to read data back to the CPU and to interact with other systems that live on the CPU.</p>
<p>If you&#39;re using a mobile platform, you&#39;ll need to verify that it supports compute shaders in order to use the VFX Graph. Otherwise, you might need to use the Built-In Particle System for CPU-based effects.</p>
<p><img src="_page_13_Figure_1.jpeg" alt=""></p>
<p>Comparing the Built-In Particle System with the VFX Graph</p>
<p>The Built-In Particle System can use the underlying physics system and interact with gameplay more directly, but its particle count is limited and its simulations must stay relatively straightforward.</p>
<p>Download the <a href="https://assetstore.unity.com/packages/vfx/particles/particle-pack-127325#description">Particle Pack</a> from the Unity Asset Store to get a set of examples with the Built-In Particle System. This sample asset demonstrates a variety of in-game effects (fire, explosions, ice, and dissolves, among others). You can also check out this <a href="https://blog.unity.com/community/unitytips-dev-takeover-vfx-and-shaders-with-harry-alisavakis?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Dev Takeover</a> for more information on using Shader Graph with the Built-In Particle System.</p>
<p>URP offers standard shaders (<a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/particles-lit-shader.html">Lit</a>, <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/particles-unlit-shader.html">Unlit,</a> <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/particles-simple-lit-shader.html">Simple Lit)</a> for the Built-In Particle System, whereas HDRP provides Shader Graph-based shader samples from the <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/HDRP-Sample-Content.html">HDRP package sample</a>. You can review the particle system feature comparison for render pipelines <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines-feature-comparison.html">here</a>.</p>
<p><img src="_page_13_Picture_6.jpeg" alt=""></p>
<p><strong>Note</strong>: Experimental features are not fully validated and are thus subject to change. The full release version of Unity is recommended for production work. Please see <a href="https://discussions.unity.com/t/unity-6-new-naming-convention/942214">this Discussions</a>  <a href="https://discussions.unity.com/t/unity-6-new-naming-convention/942214">post about how naming conventions will change</a> with the release of Unity 6.</p>
<p>You can enable experimental features from this guide via <strong>Preferences &gt; Visual Effects &gt; Experimental Operators/Blocks</strong>, as shown here:</p>
<table>
<thead>
<tr>
<th>. .</th>
<th>Preferences</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Preferences</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>ರ</td>
</tr>
<tr>
<td>General<br>2D<br>Physics<br>Al Navigation<br>V Analysis<br>Profiler<br>Asset Pipeline<br>Colors<br>Diagnostics<br>External Tools<br>GI Cache<br>Graphics<br>Jobs<br>Package Manager<br>Recorder<br>Rider<br>Scene View<br>Scene Template<br>V Search</td>
<td>Visual Effects<br>Experimental Operators/Blocks<br>Show Additional Debug info<br>Verbose Mode for compilation<br>Experimental shader externalization<br>Generate Shaders with Debug Symbols<br>Force Compilation in Edition Mode<br>Main Camera fallback<br>Show Target in Shader Graph (deprecated)<br>Authoring Prewarm Step Count Per Second 20<br>Authoring Prewarm Maximum Time</td>
<td>&gt;<br>Prefer Main Camera<br>3</td>
</tr>
<tr>
<td>Indexing<br>Shader Graph<br>Timeline</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Visual Effects</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Visual Scripting</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="-span-id-page-15-0-span-introduction-to-the-vfx-graph"><span id="page-15-0"></span>Introduction to the VFX Graph</h2>
<p>Any visual effect in the VFX Graph is made up of these two parts:</p>
<ul>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectComponent.html">Visual Effect (VFX) component</a> attached to a GameObject in the scene</li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphAsset.html">Visual Effect (VFX) Graph Asset</a> that lives at the project level</li>
</ul>
<p>As Unity stores each VFX Graph in the Assets folder, you must connect each asset to a Visual Effect component in your scene. Keep in mind that different GameObjects can refer to the same graph at runtime.</p>
<p><span id="page-16-0"></span><img src="_page_16_Picture_1.jpeg" alt=""></p>
<p>The VFX Graph Asset and Visual Effect component</p>
<h2 id="the-vfx-graph-asset-and-component">The VFX Graph Asset and component</h2>
<p>To create a new visual effect, right-click in the <strong>Project</strong> window and navigate to <strong>Create &gt; Visual Effects &gt; Visual Effects Graph</strong>.</p>
<p>This opens a creation wizard that allows you to select a starting template. You can begin with one of the default VFX Graphs or choose one of the Learning Templates from the Samples.</p>
<p>Note that the Learning Templates won&#39;t appear in the window unless the additional packages are installed in the Package Manager.</p>
<p><img src="_page_17_Picture_1.jpeg" alt=""></p>
<p>Select a template to create a new VFX Graph.</p>
<h4 id="choose-create-to-generate-a-vfx-graph-asset-in-the-project-">Choose <strong>Create</strong> to generate a <strong>VFX Graph Asset</strong> in the project.</h4>
<p>To add the effect to the scene, attach a <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectComponent.html">Visual Effect component</a> to a GameObject and then connect the VFX Graph Asset. There are few ways to do this:</p>
<ul>
<li>Drag the resulting asset into the Scene view or Hierarchy. A new default GameObject will appear in the Hierarchy window.</li>
<li>Assign the asset to an existing <strong>Visual Effect component</strong> in the Inspector. You can create an empty GameObject by right-clicking in the Hierarchy (<strong>Visual Effects &gt; Visual Effect</strong>) or create a GameObject and then manually add the Visual Effect component.</li>
<li>With a GameObject selected, drag and drop the asset into the Inspector window. This creates the Visual Effect component and assigns the asset in one quick action.</li>
</ul>
<p>The VFX Graph Asset contains all the logic. Select one of the following ways to edit its behavior:</p>
<ul>
<li>Double-click the VFX Graph Asset in the Project window.</li>
<li>Select the VFX Graph Asset in the Project window and click the <strong>Open</strong> button in the header.</li>
</ul>
<p><span id="page-18-0"></span>— Click the <strong>Edit</strong> button next to the <strong>Asset Template</strong> property in the Visual Effect component.</p>
<table>
<thead>
<tr>
<th>ﻩ<br>Do<br>BonFire<br>Clouds<br>Shaders<br>Textures<br>FlyingLeaves<br>Leaves_4x1</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><img src="_page_18_Figure_3.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>▼ Visual Effect</th>
<th></th>
<th>� 花 :</th>
</tr>
</thead>
<tbody>
<tr>
<td>T General</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Asset Template</td>
<td>� BonFire</td>
<td>Edit<br>0</td>
</tr>
<tr>
<td>Random Seed</td>
<td>0</td>
<td>Reseed</td>
</tr>
<tr>
<td>Reseed on play</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td></td>
</tr>
</tbody>
</table>
<p>Three ways to open a VFX Graph</p>
<p>The asset opens in the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html">VFX Graph window</a>, available under <strong>Window &gt; Visual Effects &gt; Visual Effect Graph</strong>.</p>
<h3 id="the-vfx-graph-window">The VFX Graph window</h3>
<p>Familiarize yourself with this <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html">window&#39;s layout,</a> including its:</p>
<ul>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html#toolbar">Toolbar</a></strong>: To access Global settings, as well as toggles for several panels</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html#using-the-node-workspace">Node workspace</a></strong>: To compose and edit the VFX Graph</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html#blackboard">Blackboard</a></strong>: To manage attributes and properties that are reusable throughout the graph</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html#vfx-control">VFX Control panel</a></strong>: To modify playback on the attached GameObject</li>
</ul>
<p><img src="_page_19_Figure_1.jpeg" alt=""></p>
<p>The VFX Graph window</p>
<p>Make sure you leave some space in the Editor layout for the Inspector. Selecting part of the graph can expose certain parameters, such as partition options and render states.</p>
<p><span id="page-20-0"></span></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>: ■×</th>
<th></th>
<th>3 Q Layers</th>
<th>▼ Default</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>Blackboard Control Advanced ▼</td>
<td>O Inspector</td>
<td></td>
<td>a :</td>
</tr>
<tr>
<td></td>
<td>O► Arc Sphere<br>ರ</td>
<td></td>
<td>1</td>
<td>(Attribute From Curve)<br>8</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Lifetime Random (Uniform)</td>
<td></td>
<td>VV</td>
<td>Attribute</td>
<td>color</td>
<td></td>
</tr>
<tr>
<td></td>
<td>O<br>A</td>
<td></td>
<td></td>
<td>Composition</td>
<td>Overwrite</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>8</td>
<td></td>
<td>Alpha Composition</td>
<td>Overwrite</td>
<td></td>
</tr>
<tr>
<td></td>
<td>O<br>B</td>
<td>10</td>
<td></td>
<td>Sample Mode</td>
<td>RandomConstantPerParticle</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Velocity from Direction &amp; Speed (New Direction)</td>
<td></td>
<td>VV</td>
<td>Mode<br>Color Mode</td>
<td>PerComponent<br>ColorAndAlpha</td>
<td>&gt;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Speed Mode</td>
<td>Constant</td>
<td>of ages of each of the later of the later of the later of the later of the later of the later of the later of the later of the later of the later of the later of the later of</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>O ► Direction<br>C × 0</td>
<td>y O<br>z 1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>0<br>Speed</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Direction Blend<br>O</td>
<td>O</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Color Random from Gradient (Constant per-particle)</td>
<td></td>
<td>VV</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Sample Mode</td>
<td>Random Constant Per Particle</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Color Mode</td>
<td>Color And Alpha</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>O<br>Color</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Seed<br>O</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-</td>
<td></td>
<td>&quot; Particle</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Inspector to change certain parameters.</p>
<h2 id="graph-logic">Graph logic</h2>
<p>You must build your visual effect from a network of nodes inside the window&#39;s workspace. The VFX Graph uses an interface similar to other <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Getting-Started.html">node-based tools,</a> such as <strong>Shader Graph</strong>.</p>
<p>Press the spacebar or right-click to create a new graph element. With the mouse over the empty workspace, select <strong>Create Node</strong> to create a graph&#39;s <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Contexts.html">Context</a></strong>, <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operators.html">Operator</a></strong>, or <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">Property</a></strong>. If you hover the mouse above an existing Context, use <strong>Create Block</strong>.</p>
<p><span id="page-21-0"></span><img src="_page_21_Figure_1.jpeg" alt=""></p>
<p>A VFX Graph can consist of a complex network</p>
<p>Opening up a complex VFX Graph can be daunting at first. Fortunately though, while a production-level graph can include hundreds of nodes, every graph follows the same set of rules – no matter its size.</p>
<p>Let&#39;s examine each part of the VFX Graph to learn how they work together.</p>
<h4 id="-systems-contexts-and-blocks-"><strong>Systems, Contexts, and Blocks</strong></h4>
<p>A VFX Graph includes one or more vertical stacks called <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Systems.html">Systems</a>. Systems define standalone portions of the graph and encompass several <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Contexts.html">Contexts</a>. A System is denoted by the dotted line that frames the Contexts it consists of.</p>
<p>Each Context is composed of individual <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Blocks.html">Blocks,</a> which can set <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Attributes.html">Attributes</a> (size, color, velocity, etc.) for its particles and meshes. Multiple Systems can work together within one graph to create the final visual effect.</p>
<p><img src="_page_22_Figure_2.jpeg" alt=""></p>
<p>The vertical logic in a graph flows downward.</p>
<p>Select <strong>Insert template</strong> from the menu dropdown to add a sample System from the existing templates to the current VFX Graph. This can help you get started with some pre-built graph logic. Select one of the Default VFX Graph Templates for a simple System, or choose one of the Learning Templates if it&#39;s similar to your intended effect (see <a href="#page-47-0">Exploring VFX sample content</a> <a href="#page-47-0">below</a>).</p>
<p><img src="_page_23_Picture_0.jpeg" alt=""></p>
<p><img src="_page_23_Picture_1.jpeg" alt=""></p>
<p>Insert a template from the menu.</p>
<p><img src="_page_23_Picture_3.jpeg" alt=""></p>
<p>The Visual Effect in the Scene and Game View</p>
<p>If you select the <strong>Minimal System</strong> template from the Default VFX Graph Templates, you&#39;ll see a barebones System, which includes four parts like this:</p>
<p><img src="_page_24_Figure_2.jpeg" alt=""></p>
<p>A Minimal System from the default templates</p>
<p>The flow between the Contexts determines how particles spawn and simulate. Each Context defines one stage of computation:</p>
<ul>
<li><strong>Spawn</strong>: Determines how many particles you should create and when to spawn them (e.g., in one burst, looping, with a delay, etc.)</li>
<li><strong>Initialize</strong>: Determines the starting Attributes for the particles, as well as the Capacity (maximum particle count) and Bounds (volume where the effect renders)</li>
<li><strong>Update</strong>: Changes the particle properties each frame; here you can apply Forces, add animation, create Collisions, or set up some interaction, such as with Signed Distance Fields (SDF)</li>
<li><strong>Output</strong>: Renders the particles and determines their final look (color, texture, orientation); each System can have multiple outputs for maximum flexibility</li>
</ul>
<p>Systems and Contexts form the backbone of the graph&#39;s &quot;vertical logic,&quot; or <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/GraphLogicAndPhilosophy.html">processing</a>  <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/GraphLogicAndPhilosophy.html">workflow.</a> Data in a System flows downward, from top to bottom, and each Context encountered along the way modifies the data according to the simulation.</p>
<p>Systems are flexible, so you can omit a Context as needed or link multiple outputs together. This example shows more than one <strong>Output Context</strong> rendering within the same System.</p>
<p><img src="_page_25_Picture_3.jpeg" alt=""></p>
<p>More than one Output Context within the same System</p>
<p>Contexts themselves behave differently depending on their individual Blocks, which similarly calculate data from top to bottom. You can add and manipulate more Blocks to process that data.</p>
<p>Click the button at the top-right corner of a Context to toggle the System&#39;s simulation space between <strong>Local</strong> and <strong>World</strong>.</p>
<p><span id="page-26-0"></span><img src="_page_26_Picture_0.jpeg" alt=""></p>
<p><img src="_page_26_Figure_1.jpeg" alt=""></p>
<p>Examples of different Blocks</p>
<p>Blocks can do just about anything, from simple value storage for <strong>Color</strong>, to complex operations such as <strong>Noises</strong>, <strong>Forces</strong>, and <strong>Collisions</strong>. They often have slots on the left, where they can receive input from Operators and Properties.</p>
<p>See the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/node-library.html">Node Library</a> for a complete list of Contexts and Blocks.</p>
<h4 id="-properties-and-operators-"><strong>Properties and Operators</strong></h4>
<p>Just as Systems form much of the graph&#39;s vertical logic, Operators make up the &quot;horizontal logic&quot; of its <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operators.html">property workflow.</a> They can help you pass custom expressions or values into your Blocks.</p>
<p><img src="_page_27_Figure_1.jpeg" alt=""></p>
<p>Horizontal logic</p>
<p>Operators flow left to right, akin to Shader Graph nodes. You can use them for handling values or performing a range of calculations.</p>
<p><img src="_page_27_Picture_4.jpeg" alt=""></p>
<p>Use the <strong>Create Node</strong> menu (rightclick or press the spacebar) to create <strong>Operator Nodes</strong>. You can also drag an Edge Connection from a property slot and release it in an empty space, which will open the same menu with only the compatible Operators displayed.</p>
<p>Create an Operator Node from the menu.</p>
<p><img src="_page_28_Picture_0.jpeg" alt=""></p>
<p>These Operators from the Bonfire sample, for instance, compute a random wind direction.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>Random Wind Direction over Time</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Perlin Noise 3D<br>Dimensions Three<br>Perlin<br>Type<br>O▼ Coordinatex<br>Total Time (VFX)<br>O<br>×<br>O<br>Y<br>Total Time @ J<br>Z<br>O<br>0<br>O Frequency 1<br>O Octaves ●<br>O Roughness --------<br>0.5<br>O Lacunarity 2<br>O► Range x -1<br>y 1</td>
<td>V<br>D<br>&gt;<br>Noise O<br>► Derivatives @ --</td>
<td>Remap (Vector3)<br>Clamp []<br>-- ◎► Input<br>O ► Old Range Min x x -1<br>O ► Old Range Max x 1<br>y 1<br>O ► New Range Min x -0.2 y O<br>z -0.2<br>O► New Range Maxx 0.2 y 0<br>z 0.2</td>
<td>Vector<br>4, v<br>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br>&gt; 0-</td>
<td>V<br>▶ ◎ --</td>
</tr>
</tbody>
</table>
<p>How wind direction is determined in the Bonfire sample</p>
<p>Properties are editable fields that connect to graph elements using the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/GraphLogicAndPhilosophy.html#property-workflow-horizontal-logic">property workflow</a>. Properties can be:</p>
<ul>
<li>Any <strong>Type</strong>, including <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">integers, floats, and booleans</a></li>
<li>Made from <strong>Compound</strong> components, such as <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">Vectors and Colors</a></li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">Cast and converted</a> (e.g., an integer to a float)</li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">Local or World space</a>; click the <strong>L</strong> or <strong>W</strong> to switch between them</li>
</ul>
<p>Properties change value according to their actual value in the graph. You can connect the input ports (to the left of the Property) to other graph nodes.</p>
<table>
<thead>
<tr>
<th></th>
<th>್  Update Particle</th>
<th>(WORLD)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Force</td>
<td></td>
<td>े</td>
<td></td>
</tr>
<tr>
<td>Mode</td>
<td>Absolute</td>
<td>D</td>
<td>Compound</td>
</tr>
<tr>
<td>O▼ Force<br>0<br>×<br>O<br>Y<br>0<br>Z</td>
<td>C x 1<br>y O<br>O<br>O</td>
<td>z 0</td>
<td>Property set<br>to Local space</td>
</tr>
</tbody>
</table>
<p>A Force Property in a Block</p>
<p><span id="page-29-0"></span><img src="_page_29_Picture_0.jpeg" alt=""></p>
<p>Property Nodes are Operators that allow you to <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">reuse the same value</a> at various points in the graph. They have corresponding global Properties that appear in the Blackboard.</p>
<p><img src="_page_29_Picture_2.jpeg" alt=""></p>
<p>Property Nodes</p>
<h4 id="-the-blackboard-"><strong>The Blackboard</strong></h4>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Blackboard.html">Blackboard</a> utility panel manages <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html">Properties</a> and <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Attributes.html">Attributes</a>. To open it, click the <strong>Blackboard</strong> button in the window <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphWindow.html#Toolbar">Toolbar</a> or use the default Shift-1 shortcut.</p>
<p>To view Properties and Attributes together, select the <strong>All</strong> tab at the top of the Blackboard. To filter by type, select the respective Properties or Attributes tab.</p>
<p>Properties you define in the Blackboard act as global variables that you can reuse throughout the graph as <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Properties.html#property-nodes">Property Nodes.</a> For example, you can define a bounding box property once and then apply it across multiple particle systems within the same graph.</p>
<p>Properties in the Blackboard are either:</p>
<ul>
<li><strong>Exposed</strong>: The green dot to the left of any Exposed Property indicates that you can see and edit it outside of the graph. Access an Exposed Property in the Inspector via script using the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/ExposedPropertyHelper.html">Exposed Property class</a>.</li>
<li><strong>Constant</strong>: A Blackboard property without a green dot is a Constant. It is reusable within the graph but does not appear in the Inspector.</li>
</ul>
<p>New properties are set to Exposed by default, and as such, appear in the Inspector. You must uncheck the <strong>Exposed</strong> option if you want to hide your Property outside of the graph, and create <strong>Categories</strong> to keep your properties organized.</p>
<table>
<thead>
<tr>
<th></th>
<th>BlackboardExample<br>+</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>All<br>Properties<br>Attributes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>▼ Properties</td>
<td></td>
</tr>
<tr>
<td>Exposed</td>
<td>· Collision Plane<br>V</td>
<td>Plane</td>
</tr>
<tr>
<td>Property</td>
<td>Exposed<br>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Value<br>Gr<br>Position<br>× 0<br>z 0<br>y 0.507957</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Normal<br>× 0<br>z 0<br>y 1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Tooltip</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Init Spawn Cone<br>V</td>
<td>Arc Cone</td>
</tr>
<tr>
<td></td>
<td>Exposed</td>
<td></td>
</tr>
<tr>
<td>Constant</td>
<td>Value<br>មិន</td>
<td></td>
</tr>
<tr>
<td>Property</td>
<td>► Cone</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Arc</td>
<td>● 6.283</td>
</tr>
<tr>
<td></td>
<td>Tooltip</td>
<td></td>
</tr>
<tr>
<td></td>
<td>▼ Attributes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Custom Attributes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>T Built-in Attributes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Basic Simulation</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&gt; 1.1 age</td>
<td>D</td>
</tr>
<tr>
<td>Attributes -</td>
<td>alive<br>&gt;</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>lifetime<br>&gt;</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>2 position<br>&gt;</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>12, velocity<br>&gt;</td>
<td>P</td>
</tr>
<tr>
<td></td>
<td>Advanced Simulation</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>&gt;   2 angle</td>
<td></td>
</tr>
<tr>
<td></td>
<td>angularVelocity<br>&gt;</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>A direction<br>&gt;</td>
<td>e</td>
</tr>
</tbody>
</table>
<p>The Blackboard and its available properties</p>
<p>The Blackboard also manages both built-in and custom Attributes, which you can drag and drop into the graph or create directly from the interface. Each Attribute includes a short description. Hover over an attribute to highlight where it appears in the graph.</p>
<p><span id="page-31-0"></span><img src="_page_31_Picture_0.jpeg" alt=""></p>
<h4 id="see-blackboard-attributes-page-38-0-below-for-more-details-">See <a href="#page-38-0">Blackboard Attributes</a> below for more details.</h4>
<p><img src="_page_31_Picture_3.jpeg" alt=""></p>
<p>The Sample Skinned Mesh template includes a custom Attribute.</p>
<h4 id="-group-nodes-and-sticky-notes-"><strong>Group Nodes and Sticky Notes</strong></h4>
<p>As your graph logic grows, use Group Nodes and <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/StickyNotes.html">Sticky Notes</a> to cut down on clutter. With Group Nodes, you can label a group of nodes and move them as one. On the other hand, Sticky Notes operate like code comments.</p>
<p>To create Group Nodes, select a group of nodes, right-click over them, then choose <strong>Group Selection</strong>. You can also use the new default shortcut, Shift + G.</p>
<p>You can also drag and drop a node into an existing Group Node. Hover the node over the Group and release it once the Group highlights. To remove a node from a Group, hold the Shift key while dragging it out.</p>
<p>By deleting a Group Node, either with the Delete key or from the right-click menu, you do not delete its included nodes.</p>
<p><span id="page-32-0"></span>Meanwhile, you can use Sticky Notes to describe how a section of the graph works, plus leave comments for yourself or your teammates. Add as many Sticky Notes as you need and freely move or resize them.</p>
<p>Each Sticky Note has a title and a body. Right-click in the graph view to create a Sticky Note. Double-click on a text area to edit its content. Set the Theme color (dark/light) and Text Size from the right click menu to organize your notes.</p>
<p><img src="_page_32_Figure_3.jpeg" alt=""></p>
<p>Work with Group Nodes and add Sticky Notes.</p>
<h4 id="-subgraphs-"><strong>Subgraphs</strong></h4>
<p>A Subgraph appears as a single node, which can help declutter your graph logic. Use it to save part of your VFX Graph as a separate asset that you can drop into another VFX Graph for reorganization and reuse. You can package Systems, Blocks, and Operators into different types of Subgraphs.</p>
<p>Subgraphs can be created directly from the Project window. Navigate to <strong>Create &gt; Visual Effect &gt; Subgraph Operator</strong> or <strong>Subgraph Block</strong> to start a new Subgraph from scratch. This method allows you to design Subgraphs without first building them within an existing VFX Graph.</p>
<p>Alternatively, you can create a Subgraph by selecting a set of nodes when editing a VFX Graph, then choosing the appropriate Subgraph type (Block or Operator) from the right-click menu. For example, if you want to convert a set of Operators, select <strong>Convert To Subgraph Operator</strong>. Save the asset to disk, and the selected nodes will be replaced with a single Subgraph node.</p>
<table>
<thead>
<tr>
<th>Velocity Noise Variation</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Get Position Current<br>Perlin Curl Nolse 3D<br>&gt;<br>Vector<br>く<br>Position .<br>. &gt; x - y - z<br>x .</td>
<td>Velocity Noise_Subgraph Operator   ✔</td>
</tr>
<tr>
<td>· · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ·<br>Multiply (Vector - Local)<br>● ト A @ * x -<br>VEX Time<br>&lt;</td>
<td>* (<br>Group Selection<br>Cut</td>
</tr>
<tr>
<td>Delta Time . -</td>
<td>Сору<br>Paste</td>
</tr>
<tr>
<td></td>
<td>Convert To Subgraph Operator<br>Delete</td>
</tr>
<tr>
<td></td>
<td>Duplicate</td>
</tr>
<tr>
<td></td>
<td>Clear Ignored Errors<br>Duplicate with edges</td>
</tr>
<tr>
<td></td>
<td>Collapse Operators<br>Uncollapse Operators</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>How to create a Subgraph</p>
<p>To create Input properties for the Subgraph, add new properties to the Blackboard and enable their Exposed flag.</p>
<p>To create Output properties for the Subgraph, add new properties, and move them to the Output Category in the Blackboard.</p>
<p>The Blackboard also allows you to define the menu Category where the Subgraph Block appears. Use this to sort or search for Subgraphs.</p>
<p>Creating a Subgraph is analogous to refactoring code. Just as you would organize logic into reusable methods or functions, a Subgraph makes elements of your VFX Graph more modular.</p>
<p><img src="_page_33_Figure_7.jpeg" alt=""></p>
<ul>
<li><span id="page-34-0"></span>— <strong>VFX asset authoring</strong>: This is where your creativity can truly take charge. Build a network of Operator Nodes to start making your own VFX Graph, and set up custom behaviors and parameters to create custom simulations. Whether you&#39;re riffing off existing samples or starting from scratch, you can take ownership of a specific effect.</li>
<li><strong>VFX scripting</strong>: This supports more experienced technical artists or graphics programmers using the <a href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/VFX.VisualEffect.html">component API</a> to customize the VFX Graph&#39;s behavior. With VFX scripting, your team can enjoy a more efficient pipeline for managing specific effects, and access advanced features like the Graphics Buffers.</li>
</ul>
<p><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CustomHLSL.html">Custom HLSL</a> in Unity 6 allows you to implement complex or unique particle behaviors that aren&#39;t easily achievable using the standard VFX Graph nodes. For example, you could create custom physics simulations, particle interactions, or flocking behaviors.</p>
<p><img src="_page_34_Figure_4.jpeg" alt=""></p>
<p>Regardless of your experience level, you can start creating effects with the VFX Graph. Begin with a premade effect to get familiar with the workflow, and then gradually assemble your own graphs.</p>
<h4 id="-attributes-"><strong>Attributes</strong></h4>
<p>An <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Attributes.html">Attribute</a> is a piece of data you might use within a System, such as the color of a particle, its position and size, or how many of them you should spawn. Attributes can be read or modified during the simulation to create dynamic effects.</p>
<p>Attributes can be of typexq float (single-precision floating-point), Vector2, Vector3, Vector4 (2D, 3D, 4D vectors), bool (true/false), or int/uint (integer/unsigned integer).</p>
<p><img src="_page_35_Picture_0.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Type</th>
<th>Description</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>position</td>
<td>Vector3</td>
<td>Defines the particle&#39;s location in System Space</td>
<td></td>
<td></td>
</tr>
<tr>
<td>velocity</td>
<td>Vector3</td>
<td>Determines the speed and direction of the<br>particle&#39;s movement</td>
<td></td>
<td></td>
</tr>
<tr>
<td>age</td>
<td>float</td>
<td>The age of the simulated element, since its<br>spawn, expressed in seconds</td>
<td></td>
<td></td>
</tr>
<tr>
<td>lifetime</td>
<td>float</td>
<td>The life expectancy of a simulated element,<br>expressed in seconds</td>
<td></td>
<td></td>
</tr>
<tr>
<td>color</td>
<td>Vector3</td>
<td>Sets the RGB color of the particle</td>
<td></td>
<td></td>
</tr>
<tr>
<td>alpha</td>
<td>float</td>
<td>Adjusts the transparency of the particle</td>
<td></td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>float</td>
<td>Controls the uniform size of the particle</td>
<td></td>
<td></td>
</tr>
<tr>
<td>scale</td>
<td>Vector3</td>
<td>Applies non-uniform scaling to the particle</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mass</td>
<td>float</td>
<td>The mass of the particle, affecting how it<br>responds to forces like gravity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>direction</td>
<td>Vector3</td>
<td>Stores arbitrary direction or can be used to guide<br>particle movement</td>
<td></td>
<td></td>
</tr>
<tr>
<td>angularVelocity</td>
<td>Vector3</td>
<td>The rotation speed of the particle, expressed in<br>degrees per second</td>
<td></td>
<td></td>
</tr>
<tr>
<td>targetPosition</td>
<td>Vector3</td>
<td>A target position the particle should move<br>towards, useful in certain effects like Line<br>Renderers</td>
<td></td>
<td></td>
</tr>
<tr>
<td>texIndex</td>
<td>float</td>
<td>The animation frame used for sampling Flipbook<br>UVs for a rendered element</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="here-are-the-some-attributes-you-ll-frequently-use-in-vfx-graph-">Here are the some Attributes you&#39;ll frequently use in VFX Graph:</h4>
<p>Attributes are essential for managing the fundamental aspects of your VFX Graph particles. See the Standard Attributes <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Reference-Attributes.html">documentation page</a> for a complete list.</p>
<p>You can also use the Attributes tab in the Blackboard (<a href="#page-29-0">see below)</a> to explore many of the builtin Attributes or for defining a custom Attribute.</p>
<p>Use nodes to read from or write to Attributes. In particular, use the:</p>
<ul>
<li><strong>Get Attribute Operator</strong> to read from Attributes in the <strong>Particle</strong> or <strong>ParticleStrip System</strong></li>
<li><strong>Experimental <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/SpawnerCallbacks.html">Spawner Callbacks</a></strong> to read from Attributes in <strong>Spawn systems</strong></li>
<li><strong>Set Attribute Block</strong> to write values to an Attribute; either set the value of the Attribute directly or use a random mode (for example, set a <strong>Color Attribute</strong> with a <strong>Random Gradient</strong> or <strong>Random Per-component Block</strong>)</li>
</ul>
<p><img src="_page_36_Figure_1.jpeg" alt=""></p>
<p>Get the Attribute with an Operator and set the Attribute with a Block.</p>
<p>Most Attributes are stored per particle, which can increase the memory footprint as the number of particles and Attributes grows. For instance, if you have 10,000 particles and each particle stores multiple Attributes like position, velocity, color, and size, the memory required to maintain this data can become significant.</p>
<p>Monitor and optimize your Attributes by using the System Attribute Summary and Current Attribute Layout displayed in the Inspector when you select a Context:</p>
<ul>
<li><strong>System Attribute Summary:</strong> This section provides an overview of all system-level Attributes being used within the current System.</li>
<li><strong>Current Attribute Layout:</strong> This shows the Attributes used in the selected Context.</li>
<li><strong>Source Attribute Layout:</strong> This shows Attributes used in the source Context (the Context that provides the initial data or input), e.g. Attributes initialized in the Initialize Context that are then used in the Update Context.</li>
</ul>
<p><img src="_page_37_Picture_0.jpeg" alt=""></p>
<p>For example, in the <strong>Trigger Event on Collide</strong> template, if you select a Context within the Dart_ Spawn System, the Inspector shows:</p>
<table>
<thead>
<tr>
<th></th>
<th>Name<br>Capacity</th>
<th></th>
<th></th>
<th>Value<br>32</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>System Attribute Summary<br>alive</td>
<td></td>
<td></td>
<td></td>
<td>Boolean</td>
<td></td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td>color</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>4 bytes</td>
<td>ReadWrite,</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>12 bytes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>angleZ<br>direction</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>4 bytes</td>
<td>ReadWrite,<br>ReadWrite</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>12 bytes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>lifetime<br>seed</td>
<td></td>
<td></td>
<td></td>
<td>Float<br>Uint32</td>
<td>4 bytes</td>
<td>ReadWrite<br>ReadWrite</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>4 bytes</td>
<td></td>
</tr>
<tr>
<td></td>
<td>position</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td>velocity</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>Read Source</td>
</tr>
<tr>
<td></td>
<td>collisionEventPosition</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>ReadSource</td>
</tr>
<tr>
<td></td>
<td>particleId</td>
<td></td>
<td></td>
<td></td>
<td>Uint32</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>pivotX</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>pivotY</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>pivotZ</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>size</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td>scaleX</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>scaleY</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>scaleZ</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read</td>
</tr>
<tr>
<td></td>
<td>axisX</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>Read Write</td>
</tr>
<tr>
<td></td>
<td>axisY</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td>axisZ</td>
<td></td>
<td></td>
<td></td>
<td>Float3</td>
<td>12 bytes</td>
<td>Read Write</td>
</tr>
<tr>
<td></td>
<td>angleX</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>Read Write</td>
</tr>
<tr>
<td></td>
<td>angleY</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td>age</td>
<td></td>
<td></td>
<td></td>
<td>Float</td>
<td>4 bytes</td>
<td>ReadWrite</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Current Attribute Layout</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>alive</td>
<td>aqe</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>color</td>
<td>color</td>
<td>color</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2<br>3</td>
<td>directio<br>lifetime</td>
<td>directio</td>
<td></td>
<td></td>
<td></td>
<td>directio angleZ positior positior positior particle</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Source Attribute Layout</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>positior</td>
<td></td>
<td></td>
<td></td>
<td>positior positior alive velocity velocity velocity</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>angleZ</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2<br>3</td>
<td>lifetime</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>color<br>collisior</td>
<td>color<br>age</td>
<td>color</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>collisior</td>
<td>collisior</td>
<td>collisior</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Inspector to see Attribute usage in the Context.</p>
<p>To optimize memory usage, a System only stores Attributes that are actively needed. If an Attribute&#39;s simulation data hasn&#39;t been stored, VFX Graph will use its default constant value instead of storing unnecessary data. See the <a href="#page-147-0">Optimization</a> section for more details about the profiling tools in VFX Graph.</p>
<h4 id="-span-id-page-38-0-span-blackboard-attributes-"><span id="page-38-0"></span><strong>Blackboard Attributes</strong></h4>
<p>The Blackboard panel now has a new section dedicated to Attributes, making it easier to create the corresponding Operators or Blocks with a context-sensitive drag and drop. These new features are available in Unity 6:</p>
<ul>
<li>Drag and drop from the Blackboard to the node workspace to create a Get Attribute Operator.</li>
<li>Drag and drop from the Blackboard to a System Context to create a <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetAttribute.html">Set Attribute</a>  <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetAttribute.html">Block</a>.</li>
</ul>
<p><img src="_page_38_Figure_5.jpeg" alt=""></p>
<p><img src="_page_39_Figure_1.jpeg" alt=""></p>
<p><img src="_page_40_Picture_1.jpeg" alt=""></p>
<p><span id="page-41-0"></span><img src="_page_41_Picture_0.jpeg" alt=""></p>
<h4 id="-events-"><strong>Events</strong></h4>
<p>The various parts of a VFX Graph communicate with each other (and the rest of your scene) through <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html">Events</a>. For example, each <strong>Spawn Context</strong> contains <strong>Start</strong> and <strong>Stop</strong> flow ports, which receive Events to control particle spawning.</p>
<table>
<thead>
<tr>
<th></th>
<th>Event</th>
<th></th>
<th></th>
<th>Event</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Event Name</td>
<td>OnPlay<br>Send</td>
<td></td>
<td>Event Name</td>
<td>OnStop</td>
<td>Send</td>
<td></td>
</tr>
<tr>
<td></td>
<td>4<br>SpawnEvent</td>
<td></td>
<td></td>
<td>SpawnEvent</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Start</td>
<td>Stop</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Spawn<br>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Spawn system</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Constant Spawn Rate</td>
<td></td>
<td>ン</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>O Rate</td>
<td>16</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>SpawnEvent</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Events control particle spawning.</p>
<p>When something needs to happen, external GameObjects can notify parts of your graph with the SendEvent method of the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/ComponentAPI.html">C# API</a>. Visual Effect components will then pass the Event as a string name or property ID.</p>
<p>An Event Context identifies an Event by its <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html">Event string name or ID inside a graph</a>. In the above example, external objects in your scene can raise an <strong>OnPlay Event</strong> to start a Spawn system or an <strong>OnStop Event</strong> to stop it.</p>
<p><img src="_page_41_Figure_8.jpeg" alt=""></p>
<p>An Output Event can send messages to the scene.</p>
<p>You can combine an <strong>Output Event</strong> with an <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/OutputEventHandlers.html">Output Event Handler</a></strong>. Output Events are useful if the initial spawning of the particles needs to drive something else in your scene. This is common for synchronizing lighting or gameplay with your visual effects.</p>
<p>The above example sends an <strong>OnReceivedEvent</strong> to a GameObject component outside of the graph. The C# script will then react accordingly to intensify a light or flame, activate a spark, etc. See the <a href="#page-123-0">Interactivity section</a> for more information on Output Events.</p>
<p>At the same time, you can use GPU Events to spawn particles based on other particle behavior. This way, when a particle dies in one system, you can notify another system, which creates a useful chain reaction of effects, such as a projectile particle that spawns a dust effect upon death.</p>
<table>
<thead>
<tr>
<th></th>
<th>** Update Particle</th>
<th>(LOCAL)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Trigger Event Rate (Over Distance)</td>
<td>ে ১</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mode</td>
<td>Over Distance</td>
<td>&gt;</td>
<td></td>
<td>GPUEvent</td>
</tr>
<tr>
<td>O Rate</td>
<td>200</td>
<td>トevt ●</td>
<td>® ► Evt</td>
<td></td>
</tr>
<tr>
<td>Set Position</td>
<td></td>
<td>ン</td>
<td></td>
<td>SpawnEvent</td>
</tr>
<tr>
<td>のト Position</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ੁ Particle</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img src="_page_42_Figure_5.jpeg" alt=""></p>
<p>These <strong>Update Blocks</strong> can send <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html#gpu-events">GPU Event</a> data in the following way:</p>
<ul>
<li><strong>Trigger Event On Die</strong>: Spawns particles on another system when a particle dies</li>
<li><strong>Trigger Event Rate</strong>: Spawns particles per second (or based on their velocity)</li>
<li><strong>Trigger Event Always</strong>: Spawns particles every frame</li>
</ul>
<p>The Blocks&#39; outputs connect to a <strong>GPU Event Context</strong>, which can then notify an <strong>Initialize Context</strong> of a dependent system. Chaining different systems together in this fashion helps you create richly detailed and complex particle effects.</p>
<p>The Initialize Context of the GPU Event system can also inherit Attributes available in the parent system prior to the Trigger Event. So, for instance, by inheriting its position, a new particle will appear in the same place as the original particle that spawned it.</p>
<h4 id="-span-id-page-43-0-span-event-attributes"><span id="page-43-0"></span>Event Attributes</h4>
<p>Use <strong>Event Attribute Payloads</strong> to pass data like 3D position or color along with the Event. These Payloads carry Attributes that implicitly travel through the graph where you can &quot;catch&quot; the data in an Operator or Block.</p>
<p>You can also read Attributes passed with <strong>Spawn Events</strong> or <strong>Timeline Events</strong>. The <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetSpawnEvent.html">Set</a>  <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetSpawnEvent.html">SpawnEvent Attribute</a> <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetSpawnEvent.html">Block</a></strong> modifies the Event Attribute in a Spawn Context.</p>
<p><img src="_page_43_Figure_4.jpeg" alt=""></p>
<p>Reading an Event Attribute in a Spawn Context</p>
<p>To catch a Payload in an Initialize Context, use <strong>Get Source Attribute Operators</strong> or <strong>Inherit Attribute Blocks</strong>.</p>
<p><img src="_page_43_Figure_7.jpeg" alt=""></p>
<p><span id="page-44-0"></span>However, it&#39;s important to keep these caveats in mind when using Event Attributes:</p>
<ul>
<li><strong>Regular Event Attributes</strong> can only be read in the Initialize Context. You cannot inherit them in Update or Output. To use the Attribute in a later Context, you must inherit and set it in Initialize.</li>
<li><strong>Output Event Attributes</strong> only carry the initial values set in the Spawn Context. They do not catch any changes that occur later in the graph.</li>
</ul>
<p>See <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/ComponentAPI.html">Sending Events</a> in the Visual Effect component API for more details.</p>
<p><img src="_page_44_Figure_5.jpeg" alt=""></p>
<h2 id="ui-improvements-in-unity-6">UI improvements in Unity 6</h2>
<p>Unity 6 includes several quality of life improvements and updates to the VFX Graph UI.</p>
<h4 id="-node-search-"><strong>Node search</strong></h4>
<p>Creating nodes or blocks now uses a <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/whats-new-17.html#node-search">hierarchical tree view</a>, making it easier to browse the node library. Enhancements include custom colors and a favorites folder for a more efficient and personalized search experience. Use the advanced search filtering to select from the available nodes.</p>
<p>The new side detail panels also display any node sub-variants (e.g., Output Particle Unlit Octagon and Output Particle Unlit Triangle are sub-variants of Output Particle Unlit Quad). You can toggle the button to show sub-variants to control their visibility. Disable it to see only the most common nodes, or enable it to access all available variants.</p>
<p><span id="page-45-0"></span><img src="_page_45_Figure_1.jpeg" alt=""></p>
<p>Creating nodes or blocks adds a side panel and search filtering.</p>
<h4 id="-activation-ports-"><strong>Activation ports</strong></h4>
<p>A Block has a special <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Blocks.html#activation-port">activation port</a>, located on the top left next to its name, which is linked to a boolean property. This port allows you to control whether a Block is active.</p>
<p>You can manually toggle the Block on or off, or connect graph logic to the port to control when the Block should be active. This allows you to implement different behaviors or states per particle within the same system.</p>
<p>Note that statically inactive Blocks are grayed out and automatically removed during compilation, resulting in zero runtime cost.</p>
<p><img src="_page_45_Figure_7.jpeg" alt=""></p>
<p>Each block includes an Activation port.</p>
<p><span id="page-46-0"></span><img src="_page_46_Picture_0.jpeg" alt=""></p>
<h4 id="-new-vfx-toolbar-"><strong>New VFX Toolbar</strong></h4>
<p>The VFX toolbar has been simplified and now includes new options for quick access to documentation and samples.</p>
<p><img src="_page_46_Picture_4.jpeg" alt=""></p>
<p>The VFX Toolbar has been simplified.</p>
<h4 id="-keyboard-shortcuts-"><strong>Keyboard shortcuts</strong></h4>
<p>The <a href="https://docs.unity3d.com/2023.3/Documentation/Manual/ShortcutsManager.html">Shortcut Manager</a> now has a VFX Graph category that lets you modify the shortcut command available in the Visual Effect Graph window. New shortcut commands have been added to speed up the VFX artist&#39;s workflow.</p>
<table>
<thead>
<tr>
<th>●●</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>Shortcuts</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Shortcuts</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Esc<br>F2</td>
<td></td>
<td></td>
<td></td>
<td>F8<br>F3<br>F5<br>F6<br>F7</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>F9</td>
<td>Unassigned Key<br>Assigned Key<br>F10 F11<br>F12<br>F13 F14</td>
<td></td>
<td></td>
<td></td>
<td>F15</td>
<td>Global Key<br>Mixed Key<br>→</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>0</td>
<td></td>
<td></td>
<td>€</td>
<td>Ins</td>
<td>Hom</td>
<td>Pg<br>Up</td>
<td>MO</td>
<td>M1<br>←</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Tab</td>
<td>(8)</td>
<td>W</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>U</td>
<td></td>
<td>0</td>
<td>D</td>
<td></td>
<td></td>
<td>Del</td>
<td>End</td>
<td>Pg<br>Dil</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Caps Lock</td>
<td></td>
<td>G</td>
<td>D</td>
<td></td>
<td>C</td>
<td>1</td>
<td>J</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Return</td>
<td></td>
<td></td>
<td></td>
<td>M4</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Shift</td>
<td></td>
<td></td>
<td>C</td>
<td></td>
<td>B</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Shift</td>
<td></td>
<td></td>
<td></td>
<td>M3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Control</td>
<td>Option</td>
<td></td>
<td>Command</td>
<td></td>
<td></td>
<td></td>
<td>Space</td>
<td></td>
<td></td>
<td></td>
<td>Command</td>
<td>Option</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Default</td>
<td></td>
<td>Import</td>
<td></td>
<td>Export</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>વ્યુ-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Category</td>
<td></td>
<td></td>
<td></td>
<td>Command</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Context</td>
<td></td>
<td></td>
<td></td>
<td>Type</td>
<td></td>
<td>Shortcut</td>
<td></td>
</tr>
<tr>
<td>SnaderGrapn</td>
<td></td>
<td></td>
<td></td>
<td>Insert Node on Link</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VFX View Window</td>
<td></td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>GR</td>
<td>A</td>
</tr>
<tr>
<td>Stage</td>
<td></td>
<td></td>
<td></td>
<td>Add Node: Coll</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VFX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>P</td>
<td></td>
</tr>
<tr>
<td>Terrain</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Add Node: Sample Texture 2D</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VEX View Window</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>CE</td>
<td></td>
</tr>
<tr>
<td>Timeline</td>
<td></td>
<td></td>
<td></td>
<td>Frame Previous</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VEX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Tools</td>
<td></td>
<td></td>
<td></td>
<td>Toggle Auto Compile</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VEX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>GA</td>
<td></td>
</tr>
<tr>
<td>TrailRenderer</td>
<td></td>
<td></td>
<td></td>
<td>Toggle Blackboard</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VFX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>价1</td>
<td></td>
</tr>
<tr>
<td>Transform</td>
<td></td>
<td></td>
<td></td>
<td>Restart VFX</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VEX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>· Space</td>
<td></td>
</tr>
<tr>
<td>UI Builder</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Add Node: Sample Gradient</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VTX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>TG</td>
<td></td>
</tr>
<tr>
<td>URP</td>
<td></td>
<td></td>
<td></td>
<td>Add Node: Multiply</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VFX View Window</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>TM</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Version Control</td>
<td></td>
<td></td>
<td>Add Node: Branch</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VFX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>TY</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Visual Effect Graph</td>
<td></td>
<td></td>
<td>Add Node: Step</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VIX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>77</td>
<td></td>
</tr>
<tr>
<td>Window</td>
<td></td>
<td></td>
<td></td>
<td>Desplact All</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VEX View Window</td>
<td></td>
<td></td>
<td>Action</td>
<td></td>
<td>AD</td>
<td></td>
</tr>
</tbody>
</table>
<p>The Shortcut Manager now has a VFX Graph category.</p>
<h2 id="-span-id-page-47-0-span-exploring-vfx-sample-content"><span id="page-47-0"></span>Exploring VFX sample content</h2>
<p>A VFX Graph is more than the sum of its parts. It requires a solid understanding of how to apply each Node and Operator, along with the ways they can work together.</p>
<p>Two samples, available in the Package Manager, can help show these features in context: The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-learningTemplates.html">VFX Graph Learning Templates</a> and the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-content.html">VFX Graph Additions.</a></p>
<table>
<thead>
<tr>
<th>00</th>
<th></th>
<th>Package Manager</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>ロ Package Manager</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+ ▼ Sort: Name (asc) ▼ Fliters ▼ Clear Fillers</td>
<td></td>
<td></td>
<td></td>
<td>:</td>
<td></td>
</tr>
<tr>
<td>In Project<br>G Updates</td>
<td>Q Search Unity Registry<br>Unity Ul</td>
<td>2.0.0 ©</td>
<td>Visual Effect Graph<br>17.0.3 · June 17, 2024   Release<br>From Unity Registry by Unity Technologies Inc.</td>
<td>Remove</td>
<td></td>
</tr>
<tr>
<td>Hi Unity Registry</td>
<td>Universal RP</td>
<td>17.0.3 €</td>
<td>com.unity.visualeffectgraph</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C My Assets</td>
<td>User Generated Content</td>
<td>3.0.1</td>
<td>Documentation Changelog Licenses</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Built-in</td>
<td>User Generated Content Bridge</td>
<td>3.0.0</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>User Reporting</td>
<td>2.0.11</td>
<td>Description Version History Dependencies Samples</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Services</td>
<td>Version Control</td>
<td>2.4.3 O</td>
<td>VisualEffectGraph Additions 26.46 MB (7)</td>
<td>Reimport</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Visual Effect Graph</td>
<td>17.0.3 €</td>
<td>Additional Assets for use with Visual Effect Graph</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Visual Scripting</td>
<td>1.9.4 (-)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Visual Studio Editor</td>
<td>2.0.22 @</td>
<td>OutputEvent Helpers 34.67 KB (3)</td>
<td>Reimport</td>
<td>Import Samples</td>
</tr>
<tr>
<td></td>
<td>Vivox</td>
<td>16.3.0</td>
<td>Additional Helper Scripts that intercept Output Events and interact with</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>WebGL Publisher</td>
<td>4.2.3</td>
<td>Game Objects</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Hands</td>
<td>1.4.1</td>
<td>Learning Templates 31.32 MB (2)</td>
<td>Reimport</td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Interaction Toolkit</td>
<td>3.0.4</td>
<td>Additional sample, composed of VFX Graph assets that explain and</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>XR Plugin Management</td>
<td>4.4.1</td>
<td>illustrate behaviors and VFX Graph concepts and features</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ZIUSDT DIGUA</td>
<td>233</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Last update Jun 27, 23:33</td>
<td>రా</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Install the sample content from the Package Manager.</p>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-learningTemplates.html">VFX Graph Learning Templates</a> showcase a number of techniques. This collection of education samples can help you explore a specific aspect or feature set of VFX Graph.</p>
<p>The sample content is compatible with both URP and HDRP projects, for VFX Graph versions 17.0 (Unity 6) and later.</p>
<p><img src="_page_47_Picture_8.jpeg" alt=""></p>
<p>Get started using the VFX Graph Learning Templates.</p>
<p>Use the Scene view to move around freely or the Game view to focus on each effect. The <strong>Sample Showcase Window</strong> in the Inspector displays the corresponding information, with quick-access links to the documentation or to navigate between effects. Each VFX asset includes embedded notes and explanations to guide you.</p>
<p>We will explore these samples in more detail under <a href="#page-55-0">Visual effects by example</a>.</p>
<p><img src="_page_48_Picture_3.jpeg" alt=""></p>
<p>Navigate each VFX Graph using the Sample Showcase Window.</p>
<p>Meanwhile, the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sample-content.html">VFX Graph Additions</a> in the Package Manager demonstrate several simple graphs, making them a starting point for learning how to manage particles. In the example below, you can see how the Smoke, Flames, and Sparks build up to form the Bonfire effect:</p>
<p><img src="_page_49_Figure_2.jpeg" alt=""></p>
<p>The Flames effect shows a basic graph.</p>
<p><img src="_page_50_Picture_1.jpeg" alt=""></p>
<p>You&#39;ll encounter some common Blocks and Operators as you explore the samples provided:</p>
<p>— <strong>Noise and Random Operators</strong>: Procedural Noise helps reduce the &quot;machine-like&quot; look of your rendered imagery. The VFX Graph provides several Operators that you can use for one-, two-, and three-dimensional <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-CellularCurlNoise.html">Noise</a> and <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-RandomNumber.html">Randomness</a>.</p>
<table>
<thead>
<tr>
<th></th>
<th>Cellular Noise 1D</th>
<th></th>
<th>V</th>
<th></th>
<th>Value Noise 2D</th>
<th></th>
<th></th>
<th>V</th>
<th></th>
<th>Perlin Curl Noise 2D</th>
<th></th>
<th>V</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Dimensions One</td>
<td>Cellular</td>
<td>&gt;<br>&gt;</td>
<td></td>
<td>Dimensions Two</td>
<td>Value</td>
<td></td>
<td>&gt;<br>&gt;</td>
<td></td>
<td>Dimensions Two</td>
<td>Perlin</td>
<td>&gt;<br>&gt;</td>
</tr>
<tr>
<td></td>
<td>Type</td>
<td></td>
<td></td>
<td>Type</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Type</td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>O<br>O</td>
<td>Coordinate ()<br>Frequency 1<br>Octaves<br>●</td>
<td>1</td>
<td>Noise O<br>Derivatives O</td>
<td>O</td>
<td>O &gt; Coordinatex 0<br>O Frequency 1<br>Octaves<br>●</td>
<td>y 0<br>1</td>
<td></td>
<td>Noise O<br>Derivatives O</td>
<td>o<br>O</td>
<td>O &gt; Coordinatex 0<br>Frequency 1<br>Octaves</td>
<td>y 0<br>1<br>œ</td>
<td>Noise O</td>
</tr>
<tr>
<td>O<br>O<br>O ► Range</td>
<td>Lacunarity 2</td>
<td>Roughness -- 0.5<br>x -1<br>y 1</td>
<td></td>
<td>O<br>O<br>O ► Range</td>
<td>Lacunarity 2</td>
<td>Roughness -- 0.5<br>x -1<br>y 1</td>
<td></td>
<td></td>
<td>O<br>O<br>O</td>
<td>Lacunarity 2<br>Amplitude   1</td>
<td>Roughness -- 0.5</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Value Curl Noise 3D<br>Dimensions Three</td>
<td></td>
<td>V<br>&gt;</td>
<td></td>
<td></td>
<td>Random Number</td>
<td>V</td>
<td>Random Vector</td>
<td></td>
<td></td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>O<br>0<br>0<br>O</td>
<td>Type<br>O &gt; Coordinatex 0<br>Frequency 1<br>Octaves<br>œ<br>Roughness -<br>Lacunarity 2</td>
<td>Value<br>y O<br>z 0<br>1<br>0.5<br>T</td>
<td>&gt;<br>Noise O</td>
<td></td>
<td>Seed<br>O<br>0<br>Max 1<br>O</td>
<td>Per Part▼<br>Constant ✔<br>Min Q<br>Seed O</td>
<td>r O</td>
<td>O &gt; Min Output x -1<br>O► Max Output x 1<br>0<br>0<br>O<br>O<br>Seed</td>
<td>Normalized<br>Per-Particle ✔<br>Constant</td>
<td>230283</td>
<td>y -1<br>z -1<br>y 1<br>z 1</td>
<td>&gt; Output O</td>
</tr>
<tr>
<td>O</td>
<td>Amplitude 1<br>Random Vector 3</td>
<td></td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>O Scale 1</td>
<td>▼ Random Vector3 O</td>
<td>x O<br>0<br>y O<br>0<br>z O</td>
<td>Page Selection<br>Seed Column ()<br>Seed Row</td>
<td>1</td>
<td>▼ RandomPage O</td>
<td>&gt;<br>× ○<br>y O</td>
<td>Random Position (Circle)<br>O &gt; Circle<br>O&gt; Transform (L)<br>O Surface</td>
<td>(1)</td>
<td>1</td>
<td></td>
<td>V<br>Position O</td>
</tr>
</tbody>
</table>
<p>Noise and Random Operators</p>
<p>— <strong>Attribute Blocks</strong>: These similarly include the option of applying Randomness in various modes. They can vary slightly per Attribute, so experiment with them to familiarize yourself with their behavior.</p>
<table>
<thead>
<tr>
<th></th>
<th>Add Age Random (Uniform)</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A<br>O</td>
<td></td>
<td>O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>B</td>
<td></td>
<td>O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Axis X Random (Per-component)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O ► A</td>
<td></td>
<td>(L)<br>× 1</td>
<td>y O</td>
<td>z 0</td>
<td></td>
</tr>
<tr>
<td>O ► B</td>
<td></td>
<td>× 1<br>(L)</td>
<td>y O</td>
<td>Z O</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Scale.XYZ Random (Per-component)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Channels</td>
<td>XYZ</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O ▶ A</td>
<td></td>
<td>× 1</td>
<td>y 1</td>
<td>z 1</td>
<td></td>
</tr>
<tr>
<td>O ► B</td>
<td></td>
<td>× 1</td>
<td>y 1</td>
<td>Z 1</td>
<td></td>
</tr>
<tr>
<td>Add Al<br>O<br>A</td>
<td>a random</td>
<td>Search</td>
<td></td>
<td>×</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>B Add Mass Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Size Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Mass Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Size Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Blend Alpha Random (Uniform) (Attribute Set)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Alpha Random from Curve (Attribute Curve)<br>Add Angle Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Pivot Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Add Scale Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Alpha Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Angle Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Pivot Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Set Scale Random from Curve (Attribute Curve)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Randomness Blocks</p>
<p>— <strong>Flipbooks</strong>: An animated texture can do wonders to make your effects believable, as you can see in the Smoke and Flames samples. Generate these from an external <strong>Digital Content Creation</strong> (DCC) tool or from within Unity. Use Operators to manage the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-FlipbookPlayer.html">Flipbook Block</a></strong>.</p>
<p>For more information on creating your own flipbooks within Unity, check out the <strong>Image Sequencer</strong> in the <a href="#page-144-0">VFXToolbox section</a>.</p>
<p><img src="_page_52_Figure_1.jpeg" alt=""></p>
<p>Flipbook Nodes</p>
<p>— <strong>Physics</strong>: <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-Force.html">Forces</a>, <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithAABox.html">Collisions</a>, and <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-LinearDrag.html">Drag</a> are essential to making particles simulate natural phenomena. But don&#39;t be afraid to push the boundaries of what&#39;s real. As the artist, you get to decide what looks just right.</p>
<p><img src="_page_52_Figure_4.jpeg" alt=""></p>
<p>Physics Blocks</p>
<p>— <strong>Subgraphs</strong>: The Smoke, Flames, and Sparks are <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Subgraph.html">Subgraphs</a>. They are the parts of a VFX Graph that can be saved as an asset for later reuse.</p>
<p>Splitting the main elements into smaller parts makes the Bonfire graph more readable. So if you need to make a new explosion effect somewhere else in your application, for example, you can now deploy it by dragging and dropping it into another graph. This works because the Subgraph is an asset.</p>
<p><img src="_page_53_Figure_4.jpeg" alt=""></p>
<p>The Bonfire graph uses three Subgraphs.</p>
<p><img src="_page_53_Picture_6.jpeg" alt=""></p>
<p>Individual Subgraph elements combine to form the Bonfire.</p>
<p><span id="page-54-0"></span><img src="_page_54_Picture_0.jpeg" alt=""></p>
<p>For a breakdown of how to construct the Bonfire graph, among other effects, watch <a href="https://www.youtube.com/watch?v=sNJ_SU20-o0&amp;list=PLtRuo28h-g1mndib2hMyp-dVfx7Jq9cOH">these</a>  <a href="https://www.youtube.com/watch?v=sNJ_SU20-o0&amp;list=PLtRuo28h-g1mndib2hMyp-dVfx7Jq9cOH">community videos</a> from Thomas Iché, a senior VFX and technical artist involved in creating the samples and the Unity Spaceship Demo.</p>
<h4 id="-more-resources-"><strong>More resources</strong></h4>
<p>Once you&#39;re familiar with the basic workings of a VFX Graph, try building a few effects from scratch. Start with a simple system for <a href="https://www.youtube.com/watch?v=X9mnHZMcgYU?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">falling snow</a>, then play around with <a href="https://www.youtube.com/watch?v=OCzGXcdyqnQ?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">fire, smoke, and</a>  <a href="https://www.youtube.com/watch?v=OCzGXcdyqnQ?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">mist</a>.</p>
<p>The following videos offer an introduction to several effects, however, please note they are using older versions of VFX Graph.:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=X9mnHZMcgYU?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Making snow with the VFX Graph</a></li>
<li><a href="https://www.youtube.com/watch?v=OCzGXcdyqnQ?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Creating fire, smoke, and mist effects with the VFX Graph in Unity</a></li>
<li><a href="https://www.youtube.com/watch?v=pNYZZk5h3lM?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Rendering particles with the VFX Graph in Unity</a></li>
<li><a href="https://www.youtube.com/watch?v=UybzSIUlzC0?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Multilayered effects with the VFX Graph in Unity</a></li>
<li><em><a href="https://www.youtube.com/watch?v=VWjn3MQHWC8?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Hardspace: Shipbreaker</a></em> <a href="https://www.youtube.com/watch?v=VWjn3MQHWC8?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Tech Talk: Explosions with the VFX Graph</a></li>
<li><a href="https://www.youtube.com/watch?v=uHD8OfSzCsg?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">Real-time VFX workflows in</a> <em>The Hereti</em>c</li>
</ul>
<h4 id="-additional-references-"><strong>Additional references</strong></h4>
<p>As you get more comfortable with the VFX Graph, you can dive deeper to discover its nuances. Keep these pages handy when you need to reference specific Node or Operator functionalities:</p>
<ul>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/node-library.html">Node Library</a> describes every Context, Block, and Operator in the VFX Graph.</li>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Reference-Attributes.html">Standard Attribute Reference</a> offers a comprehensive list of all common Attributes.</li>
<li>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/VisualEffectGraphTypeReference.html">VFX Type Reference</a> lists Data types used in the VFX Graph.</li>
</ul>
<h2 id="-span-id-page-55-0-span-visual-effects-by-example"><span id="page-55-0"></span>Visual effects by example</h2>
<p>Once you understand the fundamentals of the VFX Graph, challenge yourself to craft more complex graphs. A number of example projects are available to help you better prepare for problems you might encounter during production.</p>
<p>These samples run the gamut of what&#39;s possible for your visuals. From ambient smoke and fire to fully scripted, AAA cinematic gameplay, take your time to explore.</p>
<h2 id="vfx-graph-learning-templates">VFX Graph Learning Templates</h2>
<p>If you&#39;re still new to VFX Graph, this collection of VFX Graphs is the best place to start. The Learning Templates are composed of various real-time effects, each here to teach one or more aspects of VFX Graph.</p>
<p>The graphs are small and focused, making them ideal learning samples. Dive into each template to master a new technique or use it as a starting point for your own effect. Each graph comes with detailed notes to help you understand their construction.</p>
<p>The Learning Templates are available from the wizard when creating a new VFX Graph, or you can import them via the Package Manager as a complete sample scene for either URP or HDRP.</p>
<p>Use the VFX Samples Showcase window to navigate the samples. Let&#39;s take a quick tour of the Learning Templates.</p>
<p><span id="page-56-0"></span><img src="_page_56_Figure_1.jpeg" alt=""></p>
<p>The Samples Showcase window</p>
<h4 id="-visualizing-gizmos-"><strong>Visualizing gizmos</strong></h4>
<p>Many Blocks have adjustable parameters that may correspond to visual gizmos in the Scene view. You can change the values directly within the Blocks themselves or manipulate the gizmos in the Scene view.</p>
<p>To manipulate the gizmo, you need to &quot;attach&quot; the VFX Graph that you&#39;re editing to a corresponding VFX instance in your scene.</p>
<table>
<thead>
<tr>
<th>Link the VFX Graph to a GameObject with the VisualEffect component.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Use the small &quot;link&quot; icon near the top of the window to attach the VFX Graph to the selected GameObject with Visual Effect component.</p>
<p>Once attached, selecting the corresponding block in the VFX Graph editor will sync and display. Use the handles of the gizmo to change the settings interactively.</p>
<p><span id="page-57-0"></span><img src="_page_57_Figure_1.jpeg" alt=""></p>
<h4 id="-graph-fundamentals-"><strong>Graph fundamentals</strong></h4>
<p>These samples show the basics of graph logic and how to build and optimize your VFX Graphs.</p>
<h4 id="contexts-data-flow">Contexts &amp; Data Flow</h4>
<p>This sample provides an overview and basic understanding of how data flow is handled in VFX Graph. It also presents an overview of the most frequently used Contexts and Blocks.</p>
<p><img src="_page_57_Picture_6.jpeg" alt=""></p>
<p>The Contexts &amp; Data Flow sample</p>
<h4 id="-span-id-page-58-0-span-spawn-context"><span id="page-58-0"></span>Spawn Context</h4>
<p>This VFX Graph demonstrates how to use the options in the Spawn Context to control how particles first appear. By utilizing the Spawn State, you can access valuable information such as the loop index, spawn count, loop state, and loop duration.</p>
<p>In the example effect, a stack of numbers appears to count up by manipulating the texture index. This is achieved by generating a single burst of particles with a small delay between each burst.</p>
<p><img src="_page_58_Picture_4.jpeg" alt=""></p>
<p>Use the Spawn Context.</p>
<p>Additionally, this example shows how to set attributes like lifetime, color, and alpha in the Spawn Context so they can later be inherited in the Initialize Particle Context.</p>
<h4 id="capacity-count">Capacity Count</h4>
<p>This VFX Graph generates randomly sized particles within a volume to demonstrate how to use the Capacity attribute.</p>
<p>Capacity Count is used for the particle memory allocation of a system. Increasing this number will increase the memory allocated. This capacity serves as the maximum for the current number of active particles.</p>
<p><span id="page-59-0"></span><img src="_page_59_Picture_1.jpeg" alt=""></p>
<p>Increasing the Capacity Count increases the allocated memory.</p>
<h4 id="multiple-outputs">Multiple Outputs</h4>
<p>This VFX Graph demonstrates how the Initialize or Update context can be wired to one or several output contexts. This allows you to create one particle simulation and generate several types of renderer on each particle.</p>
<p>In this demo, each particle renders as an unlit particle, a mesh, and a quad. For example, imagine using a Mesh Output to make the core of a missile and then a second Quad Output to add an emissive glow on top of it.</p>
<p><img src="_page_59_Figure_6.jpeg" alt=""></p>
<p>Use multiple Outputs for different effects.</p>
<p><span id="page-60-0"></span><img src="_page_60_Picture_0.jpeg" alt=""></p>
<p>Note that some Outputs are only compatible with a particular SRP (e.g. the HDRP Volumetric Fog output is only compatible with HDRP).</p>
<h4 id="bounds">Bounds</h4>
<p>This shows how the Bounds settings can cull an effect to improve performance. In this example, the Bounds are deliberately set outside the camera frustum by default. As a result, the particles are culled (in this example, they may still cast shadows if enabled for the Output Context).</p>
<p>Adjust the Bounds settings so the Bounds gizmo is within the camera frustum and the particles reappear.</p>
<h4 id="select-a-bounds-mode-">Select a <strong>Bounds Mode:</strong></h4>
<ul>
<li><strong>Manual:</strong> Set the Bound Size and Center manually.</li>
<li><strong>Recorded:</strong> This allows users to record the Bounds using the VFX Control and then apply those settings to the system.</li>
<li><strong>Automatic:</strong> Bounds will be computed each frame. This can be needed for dynamic VFX or when iterating on a VFX but is resource intensive. Use Manual or Recorded when possible.</li>
</ul>
<p><img src="_page_60_Picture_10.jpeg" alt=""></p>
<p>Adjust the Bounds settings to make the particles reappear.</p>
<h4 id="-span-id-page-61-0-span-particle-orientation-and-rotation-"><span id="page-61-0"></span><strong>Particle orientation and rotation</strong></h4>
<p>Whether the output is set to quads, meshes, or even strips, you&#39;ll often want to control the orientation of the geometry on a particle. Should it face the camera? What is the forward and/ or up-axis? The Orient Block helps you to easily orient your particles with its various modes.</p>
<p>The <strong>Orient Face Camera</strong>, <strong>Orient Fixed Axis</strong>, and <strong>Orient Advanced</strong> VFX Graphs demonstrate different ways of using particle orientation.</p>
<p><img src="_page_61_Picture_4.jpeg" alt=""></p>
<p>These samples show different ways to orient the particles.</p>
<p>You can also rotate particles using the Angle attribute, as seen in the <strong>Rotation &amp; Angle</strong> VFX Graph.</p>
<p><img src="_page_61_Figure_7.jpeg" alt=""></p>
<p>Use the Angle attribute to rotate the particles.</p>
<p>For more realistic results, use angular velocity. The <strong>Rotation &amp; Angular Velocity</strong> sample shows how to set this in the Initialize Context and then use the Update Context to update the rotation.</p>
<p><span id="page-62-0"></span><img src="_page_62_Picture_2.jpeg" alt=""></p>
<p>Use angular velocity for more realistic motion</p>
<h4 id="-texturing-and-flipbooks-"><strong>Texturing and flipbooks</strong></h4>
<p>Real-time VFX often rely on sprite sheets.The <strong>TexIndex Attribute</strong> sample shows how to set up the UVs mode of the Output to Flipbook to use a Sprite sheet.</p>
<p>While the Flipbook Block helps animate your sprite sheet, you can control this manually by manipulating the <strong>texIndex</strong> attribute, a float that determines which part of a sprite sheet to display.</p>
<p>In the <strong>Flipbook Mode</strong> VFX Graph, compare how enabling <strong>Flipbook Blend Frames</strong> can create smoother, interpolated animation beyond the basic animated flipbook texture.</p>
<p>The <strong>Flipbook Blending</strong> VFX Graph illustrates the differences between traditional frame blending and frame blending using motion vectors. Motion vector blending uses a texture to describe the pixel displacement between frames, which can be useful for reducing the number of frames in the flipbook or for showing the effect in slow-motion.</p>
<p><img src="_page_63_Figure_1.jpeg" alt=""></p>
<p>These samples show the use of flipbook textures.</p>
<p>The <strong>TexIndex Advanced</strong> VFX Graph is composed of several systems that are playing with the <strong>texIndex</strong> attribute creatively. Time, noise, and even particle position are used to drive the attribute values. By animating several particles together, this setup produces a multilayered motion graphic effect.</p>
<p><img src="_page_63_Picture_4.jpeg" alt=""></p>
<p>Combine several systems in a motion graphic effect.</p>
<p><span id="page-64-0"></span><img src="_page_64_Picture_0.jpeg" alt=""></p>
<h4 id="-particle-pivots-"><strong>Particle pivots</strong></h4>
<p>By default, the pivot is centered on the particle&#39;s position, but you can offset it on any axis (XYZ). In the <strong>Pivot Attribute</strong> VFX Graph, each particle has a different pivot offset and angular velocity.</p>
<p><img src="_page_64_Picture_4.jpeg" alt=""></p>
<p>The Pivot Attribute VFX Graph shows three particles with different pivots.</p>
<table>
<thead>
<tr>
<th></th>
<th>Pivot Offset</th>
<th>&gt; Set Position Sequential Line<br>O<br>&lt;<br>✔ Set Tex Index Random Uniform<br>O</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Get Particle Id Current ✔<br>Location<br>Current ▼</td>
<td>Switch<br>3<br>Entry Count</td>
<td>ಿ<br>V</td>
<td>O<br>✔ Set Pivot.XYZ<br>V<br>XYZ<br>Channels</td>
<td></td>
</tr>
<tr>
<td>Particle Id ●</td>
<td>. Test Value<br>O ► Value O<br>хо у о<br>z O<br>O ► Value 1<br>z O<br>x 0.5 y<br>0<br>O ► Value 2<br>y O<br>Z 0.5<br>× 0<br>O ► Default<br>ZO<br>x 0 y 0.5</td>
<td></td>
<td>● ▶ Pivot<br>x - y -<br>Z<br>O<br>✔ Set Size<br>✔ Set Angular Velocity.XYZ<br>O</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>● ► Angular Velocity<br>x - -<br>y - Z<br>್ಕ್ Particle</td>
</tr>
</tbody>
</table>
<p>Adjust the particle pivots.</p>
<p>Controlling the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Reference-Attributes.html#size-scale-and-pivot">Pivot</a></strong> attribute of a particle can unlock interesting motion. The <strong>Pivot Advanced</strong> VFX Graph gives an example of pivot manipulation. Here, the petals, leaves and spikes of the flower are all particles.</p>
<p><span id="page-65-0"></span>Initially, the petal&#39;s pivot is set at its root to allow for proper bending while the petal is attached. As the particle&#39;s lifetime progresses, the pivot is animated to shift to the center, allowing the petal to break away and float off naturally.</p>
<p><img src="_page_65_Picture_2.jpeg" alt=""></p>
<p>Animating the pivots creates interesting motion.</p>
<h4 id="-mesh-and-texture-sampling-"><strong>Mesh and texture sampling</strong></h4>
<p>The <strong>Mesh Sample</strong> VFX Graph demonstrates sampling a mesh to spawn particles. The graph uses the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-SampleMesh.html">Sample Mesh</a></strong> operator, with the <strong>Mesh</strong> input referencing the desired mesh and the <strong>Placement Mode</strong> set to <strong>Surface</strong>.</p>
<table>
<thead>
<tr>
<th></th>
<th>Sample Mesh</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Mode</td>
<td>Wrap</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>Placement Mode</td>
<td>Surface</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td>Surface Coordinates</td>
<td>Uniform</td>
<td>▶</td>
</tr>
<tr>
<td>1</td>
<td>Mesh</td>
<td>Position<br>■ Lion<br>ල<br>7</td>
<td>•</td>
</tr>
<tr>
<td>•</td>
<td>Triangle</td>
<td></td>
<td>O<br>×</td>
</tr>
<tr>
<td>0</td>
<td>Square</td>
<td>X<br>y</td>
<td>O<br>y<br>O<br>Z</td>
</tr>
<tr>
<td>•</td>
<td>×</td>
<td>&gt;</td>
<td>O<br>Color</td>
</tr>
<tr>
<td>C</td>
<td>Y</td>
<td></td>
<td>•<br>x</td>
</tr>
<tr>
<td>O</td>
<td>Transform</td>
<td>જીર</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>&gt;<br>Position</td>
<td>Z 0<br>× 0<br>y O</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>Angles<br>A</td>
<td>Z O<br>× 0<br>y 345.C</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>Scale<br>A</td>
<td>z 0.7<br>× 0.7<br>0.7<br>y</td>
</tr>
</tbody>
</table>
<p>Use the Sample Mesh node to place particles on the surface.</p>
<p>This randomly spawns particles on the surface of the mesh. The <strong>Position</strong> and <strong>Color</strong> outputs pass into an Initialize Particle Context that stores the particle properties for later animation. In this example, an external wind force and turbulence disperse the lion statue into a cloud of dust.</p>
<p><img src="_page_66_Picture_2.jpeg" alt=""></p>
<p>Spawn particles on the surface of a mesh.</p>
<p>You can achieve a similar effect using a 2D image. The <strong>Sample Texture 2D</strong> VFX Graph shows how to use the Texture2D Sample operator to determine the color of particles and perform rejection sampling. The graph spawns particles in a 2D grid and remaps their XY coordinates to sample the texture. Then, particles die based on a threshold of the sampled texture values.</p>
<p><img src="_page_66_Picture_5.jpeg" alt=""></p>
<p>Spawn particles on a 2D image.</p>
<p>You can also sample a <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sdf-in-vfx-graph.html">signed distance field (SDF)</a>, a technique to represent a shape and contours of 2D or 3D objects. An SDF calculates the distance from any point in space to the nearest point on the object&#39;s surface. The <strong>SampleSDF</strong> VFX Graph demonstrates how to make particles crawl along the surface of the mesh using an SDF.</p>
<p><img src="_page_67_Picture_2.jpeg" alt=""></p>
<p>Spawn particles on a signed distance field.</p>
<p>If you need to apply effects to a rigged character or prop, sample a skinned mesh to get information about its surface position, vertex colors, UVs, normals, etc. The <strong>Sample Skinned Mesh</strong> VFX Graph retrieves the surface UVs in order to spawn feathers on the creature&#39;s back.</p>
<table>
<thead>
<tr>
<th></th>
<th>Mesh Coordinates</th>
<th>Sample SI</th>
<th>kinned Mesh<br>乡 Initialize Particle<br>Cocal</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>O Random Float .<br>O Random Floot .<br>O Random Float .</td>
<td>Capacity<br>Bounds Mode<br>O ▼ Bounds<br>O &gt; Center<br>O &gt; Size<br>O &gt; Set Skinned Coord<br>. X<br>. Y<br>. 2</td>
<td>30000<br>Manual<br>હિ<br>×0<br>y 1.5 z z o<br>×3<br>y 4 z 3<br>O = Skinned Coord = x = x = x = x =</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Skinned Mesh<br>· SkinnedMeshRenderer &lt;<br>SkinnedMeshRenderer . -</td>
<td>O ✔ Set Position Mesh Skinned Mesh<br>Mode<br>Placement Mode<br>Surface Coordinates<br>Skinned Transform<br>Spawn Mode<br>O Blend Axes<br>O Blend Direction</td>
<td>V<br>Wrap<br>Surface<br>Uniform<br>ApplyLocalRootTransform<br>Custom<br>-0<br>-- 0.531</td>
<td></td>
</tr>
<tr>
<td>Sample Skinned Mesh</td>
<td>Get Skinned Coord Current O -</td>
<td>· Skinned Mesh<br>· Triangle<br>O ▼ Square<br>. ×<br>. Y<br>O ▼ Transform<br>O &gt; Position<br>O &gt; Angles<br>O &gt; Scale<br>O V Set Size</td>
<td>None (Skinned Mesh Renderer)<br>x - x - y - y - - -<br>છે.<br>× 0<br>yo your zo<br>20<br>× 0<br>yo<br>y 1 y 1 = 2 1<br>× 1</td>
</tr>
</tbody>
</table>
<p>Sampling a skinned mesh drives this effect.</p>
<p><span id="page-68-0"></span><img src="_page_68_Picture_0.jpeg" alt=""></p>
<h4 id="-collisions-and-interactivity-"><strong>Collisions and interactivity</strong></h4>
<p>Because VFX Graph simulates particles on the GPU, its particles cannot collide with regular Rigidbody Colliders. However, they can still collide with geometric primitives (Box, Cone, Plane, or Sphere) or complex shapes via the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithSignedDistanceField.html">Collide with Signed Distance Field</a> or <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithDepthBuffer.html">Collide with</a>  <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithDepthBuffer.html">Depth Buffer</a> Blocks.</p>
<p><img src="_page_68_Picture_4.jpeg" alt=""></p>
<p>The Collision Simple VFX Graph</p>
<p>Open the <strong>Collision Simple</strong> VFX Graph to see how to set up basic collision graph logic.</p>
<p>The <strong>Collision Properties</strong> VFX Graph demonstrates how properties like bounce, friction, lifetime loss, and roughness can influence the collision response of particles.</p>
<p>Bounce, friction, and roughness affect collisions.</p>
<p>In Unity 6, individual <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithSphere.html">Collider Blocks</a> have been combined into the Collision Shape Block so that you can easily switch between shapes. Several options have been added, with improvements to both stability and accuracy. Chain several Collision Shape Blocks within a Context for the desired effect.</p>
<table>
<thead>
<tr>
<th>V Add Velocity<br>O</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>Velocity<br>O</td>
<td>x - y -<br>137<br>Z</td>
</tr>
<tr>
<td>Collision Shape Signed Distance Field<br>0</td>
<td>Y</td>
</tr>
<tr>
<td>Shape<br>Mode<br>Radius Mode<br>Collision Attributes<br>Rough Surface</td>
<td>SignedDistanceField<br>&gt;<br>Sphere<br>Oriented Box<br>Cone<br>Plane</td>
</tr>
<tr>
<td>Distance Field<br>O<br>O<br>Field Transform<br>Center<br>œ<br>O<br>Y</td>
<td>✔ SignedDistanceField<br>9<br>× 0<br>y 0.923<br>Z 0</td>
</tr>
<tr>
<td>&gt; Size<br>0<br>O<br>Bounce<br>O<br>Friction<br>Lifetime Loss<br>O<br>O<br>Radius</td>
<td>y 2.08<br>× 1.6<br>Z 2<br>0.1<br>0.7<br>0<br>0.01</td>
</tr>
<tr>
<td>Collision Shape Cone / Cylinder<br>0</td>
<td>V</td>
</tr>
<tr>
<td>Shape<br>Mode<br>Radius Mode<br>Collision Attributes<br>Rough Surface</td>
<td>Cone<br>&gt;<br>Solid<br>&gt;<br>&gt;<br>None<br>NoWrite<br>&gt;</td>
</tr>
<tr>
<td>O<br>Cone<br>O<br>Bounce<br>O<br>Friction<br>0<br>Lifetime Loss</td>
<td>13<br>0.1<br>0.4<br>0</td>
</tr>
<tr>
<td>✔ Collision Shape Sphere<br>0</td>
<td>V</td>
</tr>
<tr>
<td>Shape<br>Mode<br>Radius Mode<br>Collision Attributes<br>Rough Surface</td>
<td>Sphere<br>&gt;<br>Solid<br>&gt;<br>None<br>&gt;<br>NoWrite<br>&gt;</td>
</tr>
<tr>
<td>O &gt; Sphere<br>0<br>Bounce<br>Friction<br>O<br>O<br>Lifetime Loss</td>
<td>જુન<br>0.1<br>0.5<br>0<br>●</td>
</tr>
<tr>
<td></td>
<td>&quot; Particle</td>
</tr>
</tbody>
</table>
<p>Switch collider shapes using the Collision Shape Block.</p>
<p>Several new collision attributes (<strong>collisionEventCount</strong>, <strong>collisionEventNormal</strong>, <strong>collisionEventPosition</strong>, and <strong>hasCollisionEvent</strong>) provide detailed information for collision events, allowing for more precise control and interactivity.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>CollisionAdvanced</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>All</td>
<td>Properties<br>Attributes</td>
<td></td>
</tr>
<tr>
<td>Get Collision Event Count Current &amp;</td>
<td></td>
<td>&gt;   2, axisY</td>
<td>B</td>
</tr>
<tr>
<td>Location<br>Current<br>▶</td>
<td></td>
<td>&gt;   xisZ</td>
<td>e</td>
</tr>
<tr>
<td>Collision Event Count O</td>
<td>V</td>
<td>collisionEventCount</td>
<td>e</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Type</td>
<td>Uint</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Read-Only<br>Description</td>
<td>Yes</td>
</tr>
<tr>
<td>Get Collision Event Normal Current &amp;</td>
<td></td>
<td>Outputs the number of total collisions detected by<br>the particle since its birth</td>
<td></td>
</tr>
<tr>
<td>Current<br>Location<br>&gt;</td>
<td></td>
<td></td>
<td>B</td>
</tr>
<tr>
<td>Collision Event Normal O<br>D</td>
<td></td>
<td>√   collisionEventNormal<br>Type<br>Vector3</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Read-Only</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Description</td>
<td></td>
</tr>
<tr>
<td>Get Collision Event Position Current &amp;</td>
<td></td>
<td>Outputs the collider normal at collision point at this<br>frame. (0,0,0) if no collision</td>
<td></td>
</tr>
<tr>
<td>Location<br>Current<br>&gt;</td>
<td>&gt;</td>
<td>&amp; collisionEventPosition</td>
<td>e</td>
</tr>
<tr>
<td>Collision Event Position O</td>
<td></td>
<td>Type<br>Vector3</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>Read-Only</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Description<br>Outputs the collision point at this frame. (0,0,0) if no<br>collision</td>
<td></td>
</tr>
<tr>
<td>Get Has Collision Event Current &gt;</td>
<td></td>
<td>&gt;   color</td>
<td>P</td>
</tr>
<tr>
<td>Location<br>Current<br>▶</td>
<td></td>
<td>L direction</td>
<td>e</td>
</tr>
<tr>
<td>Has Collision Event O</td>
<td></td>
<td>hasCollisionEvent</td>
<td>D</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Type</td>
<td>Bool</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Read-Only</td>
<td>Yes</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Description<br>Outputs true at particle collision</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>.f lifetime<br>&gt;</td>
<td>A</td>
</tr>
</tbody>
</table>
<p>New Collision Attributes allow for more precise control over particle collisions.</p>
<p><span id="page-71-0"></span>If simple collision shapes aren&#39;t enough to get a precise enough collision with the environment, a signed distance field can be a good solution to approximate complex geometry. The <strong>Collision Advanced</strong> VFX Graph shows how to use the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithSignedDistanceField.html">Collide with Signed Distance Field</a> Block for particle collisions with the sculpture of a hand.</p>
<p><img src="_page_71_Picture_2.jpeg" alt=""></p>
<p>Signed distance fields can approximate complex geometry for collisions.</p>
<h4 id="-decal-particles-"><strong>Decal particles</strong></h4>
<p>Use decals to project textures on the environment and even on dynamic objects or skinned meshes. These can add visual complexity to your scene without significantly impacting performance. Common decals may include:</p>
<ul>
<li>Bullet holes or scorch marks</li>
<li>Dirt and grime</li>
<li>Graffiti, posters, or signage</li>
<li>Tracks and footprints</li>
<li>Vegetation and moss</li>
</ul>
<p>Output Decals allow you to render particles as decals and to project their properties onto a surface using a base color map (albedo), a normal map, or a mask map. This example shows how to project decals onto an animated Skinned Mesh Renderer component.</p>
<p><span id="page-72-0"></span><img src="_page_72_Picture_1.jpeg" alt=""></p>
<p>Decals add visual complexity, even to dynamic objects.</p>
<h4 id="-particle-strips-"><strong>Particle Strips</strong></h4>
<p>A Particle Strip System is a linked group of particles that can create an effect like a ribbon or trail by drawing quads between them. Take these two simple Particle Strips from the <strong>Strip Properties</strong> template: A line on the left and a wider ribbon on the right.</p>
<p><img src="_page_72_Picture_5.jpeg" alt=""></p>
<p>The Strip Properties template creates two Particle Strips.</p>
<p>To generate Strips, you use the Initialize Particle Strip Context, where you set the Strip Capacity and Particles Per Strip Count. These settings determine the maximum number of strips the system will handle and how many particles will compose each strip. Both settings influence the strip&#39;s appearance and behavior.</p>
<p>Inside the graph, note that a few Attributes are specific to Particle Strips:</p>
<ul>
<li>The <strong>Strip Index</strong> defines which strip each particle belongs to. In a simple setup like this one, all the particles fall along one Particle Strip, so they share a Strip Index of 0.</li>
<li>The <strong>ParticleIndexInStrip</strong> Attribute is a uint that represents the particle&#39;s position within the Particle Strip Buffer. This is a number between 0 and the total number of particles within the strip (in this example, between 0 and 8).</li>
<li>This <strong>SpawnIndexInStrip</strong> Attribute is a uint that represents the Spawn Index in the Strip. Unlike the ParticleIndexInStrip attribute, the SpawnIndexinStrip isn&#39;t a unique ID. Two particles born on different frames on the same strip could have the same index value.</li>
</ul>
<p>In this example, since all particles are spawned in the same frame using a single burst, the values of SpawnIndexInStrip and ParticleIndexInStrip are identical.</p>
<p>The Initialize ParticleStrip Context connects to an Update ParticleStrip Context. Finally, an Output ParticleStrip Context renders the ParticleStrip. Here, Tiling Mode options like Stretch, Repeat Per Segment, and Custom allow you to control how textures are mapped along the strip.</p>
<p><img src="_page_73_Picture_8.jpeg" alt=""></p>
<p>Setting up a Particle Strip.</p>
<p><img src="_page_74_Picture_0.jpeg" alt=""></p>
<p>There are several ways to spawn particles, and when dealing with Particle Strips, this can have some implications for how you need to set up your VFX Graph. These examples show a variety of different setups.</p>
<p>The <strong>Strip SpawnRate</strong> template shows how to make a single trail out of a continuous spawn rate of particles.</p>
<p>The <strong>Multi-Strip SpawnRate</strong> template shows how to make multiple trails out of a continuous spawn rate.</p>
<p><img src="_page_74_Picture_5.jpeg" alt=""></p>
<p>These examples use continuous spawn rates to create the trails.</p>
<p>This example generates several robot arms out of a single burst. See the <strong>Multi-Strip Single Burst</strong> template to see how to set up the Strip Index (divide the Spawn Index by the number of particles per Strip).</p>
<p>The robot tentacle is a Particle Strip while the claw arm at the end is a Lit Mesh Particle.</p>
<p><img src="_page_75_Picture_3.jpeg" alt=""></p>
<p>This uses a single burst to create multiple Particle Strips.</p>
<p>Meanwhile, the <strong>Multi-Strip Periodic Burst</strong> example shows how to create new trails for each periodic burst in a system. The Loop Index is stored as the texIndex for use outside the Spawn Context. This value is then used as the Strip Index during initialization and then normalized into a &quot;strip ratio.&quot;</p>
<p>Calculating this strip ratio can be useful when dealing with Particle Strips. In this example, it influences their behavior and appearance, such as how they stretch, change size, and respond to forces like gravity and turbulence.</p>
<p><img src="_page_76_Picture_3.jpeg" alt=""></p>
<p>Calculate a strip ratio to manage Particle Strip behavior.</p>
<p>This <strong>Strip GPU Event</strong> example shows an example of a growing mushroom VFX. The mushroom&#39;s cap (the Mushroom Hat System) renders particle meshes while the mushroom&#39;s stems (the Mushroom Foot System) is made from Particle Strips.</p>
<p>One system acts like a &quot;parent&quot; to the other, using GPU Events to trigger the next system.</p>
<p>This mechanism also generates clouds of dust and smoke as the mushrooms reach full growth, adding to the effect.</p>
<p><img src="_page_76_Picture_8.jpeg" alt=""></p>
<p>GPU Events drive the mushroom growth.</p>
<p>The <strong>Multi-Strips GPU Event</strong> template demonstrates how to create a more complex effect with Particle Strips. In this example, each headphone jack is a particle mesh that spawns particles along its path, bypassing the usual one-strip-per-parent particle.</p>
<p>As each jack follows a Bezier path from the floor to the plugs beneath the speakers, it leaves a trail of snaking cables that move organically. When a jack successfully connects, additional green light particles add a dynamic touch to the effect.</p>
<p><img src="_page_77_Picture_3.jpeg" alt=""></p>
<p>Particle Strips snake behind the headphone jacks.</p>
<p><span id="page-78-0"></span><img src="_page_78_Picture_0.jpeg" alt=""></p>
<h2 id="the-vfx-graph-samples-hdrp-">The VFX Graph Samples (HDRP)</h2>
<p>The <strong><a href="https://github.com/Unity-Technologies/VisualEffectGraph-Samples">Visual Effect Graph Samples</a></strong> highlight different scenarios that involve the VFX Graph. You can view some of the example graphs as case studies, so it&#39;s helpful to download and keep the project as a working reference.</p>
<p><strong>Note</strong>: The samples only support HDRP and are therefore incompatible with URP.</p>
<p><img src="_page_78_Picture_5.jpeg" alt=""></p>
<p>One of the VFX Graph Samples available in the repository</p>
<p>Go to the <a href="https://github.com/Unity-Technologies/VisualEffectGraph-Samples/releases">Release</a> tab to find snapshots of these samples, as well as links to prebuilt binaries. Alternatively, you can clone the entire repository.</p>
<p>Each sample appears in a subdirectory within the project&#39;s <strong>Assets/Samples</strong> folder. The main <strong>VisualEffectsSample</strong> scene lives at the root.</p>
<p><span id="page-79-0"></span><img src="_page_79_Picture_0.jpeg" alt=""></p>
<p>If you need to build a player, ensure this main scene is set to index zero within the <strong>Build Settings</strong>. Then add all other scenes you plan to cycle afterward.</p>
<table>
<thead>
<tr>
<th>Build Settings</th>
<th></th>
<th></th>
<th>: ■×</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scenes In Build</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V VisualEffectSamples<br>✔ Samples/UnityLogo/UnityLogo<br>V Samples/MorphingFace/MorphingFace<br>V Samples/Butterflies/Butterflies<br>✓ Samples/GrassWind/GrassWind<br>Samples/Volumetric/Volumetric<br>✔ Samples/Portal/Portal<br>✔ Samples/ARRadar/ARRadar<br>Samples/VoxelizedTerrain/VoxelizedTerrain<br>V Samples/GenieMagicLamp/Genie<br>V Samples/SpaceshipHoloTable/SpaceshipHoloTable<br>Samples/EllenHologram/EllenHologram<br>V Samples/BonFire/BonFire<br>✔ Samples/RibbonPack/RibbonPack<br>√ Samples/MagicBook/MagicBook<br>V Samples/Meteorite/MeteoriteSample<br>v Samples/EllenSkinnedMesh/EllenSkinnedMeshEffects<br>V Samples/GooBall/GooBall</td>
<td></td>
<td></td>
<td>0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</td>
</tr>
<tr>
<td></td>
<td></td>
<td>Add Open Scenes</td>
<td></td>
</tr>
<tr>
<td>Platform</td>
<td>Windows, Mac, Linux</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ત્વે<br>Windows, Mac, Linux</td>
<td>Target Platform</td>
<td>Windows</td>
<td>▶</td>
</tr>
<tr>
<td></td>
<td>Architecture</td>
<td>Intel 64-bit</td>
<td>▼</td>
</tr>
<tr>
<td>Dedicated Server</td>
<td>Copy PDB files</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Android</td>
<td>Create Visual Studio Solution</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Development Build<br>Autoconnect Profiler</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iOS<br>108</td>
<td>Deep Profiling</td>
<td></td>
<td></td>
</tr>
<tr>
<td>554 PS4</td>
<td>Script Debugging</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Compression Method</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td>PS5 PS5</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>WebGL</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Universal Windows Platform</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>T Asset Import Overrides</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>No Override<br>Max Texture Size</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Texture Compression No Override</td>
<td></td>
<td>Learn about Unity Cloud Build</td>
<td></td>
</tr>
<tr>
<td>Player Settings</td>
<td></td>
<td>Build<br>Build And Run<br>&gt;</td>
</tr>
</tbody>
</table>
<p>The Build Settings</p>
<p>Each scene part of the VFX Graph Samples showcases a unique effect. Let&#39;s take a closer look at some of them.</p>
<h4 id="-smoke-portal-"><strong>Smoke Portal</strong></h4>
<p>The <strong>Smoke Portal</strong> is a swirling vortex of dense, volumetric smoke that forms a mystical portal. The effect combines a Houdini-simulated smoke animation with real-time lighting using the new <strong>six-way smoke lighting</strong> material (see <a href="#page-83-0">below</a>). This technique allows VFX Graph to use baked light maps from six axes.</p>
<p>Surrounding the main portal are additional elements that enhance its magical appearance. These include flickering flames, sparks, floating rocks, and a subtle distortion effect that warps the space around the portal.</p>
<p><img src="_page_80_Picture_2.jpeg" alt=""></p>
<p>The Smoke Portal showcases the six-way smoke lighting material.</p>
<p>This <a href="https://www.youtube.com/watch?v=57cKxN3XdEY">making-of video</a> walks you through the complete workflow for this sample. Here are some important steps in how it&#39;s made:</p>
<p>— <strong>Houdini simulation:</strong> The smoke portal VFX is composed of layers including a smoke simulation exported from Houdini. The original vortex starts from a torus with noise in Houdini. Density, temperature, and velocity attributes drive the smoke simulation, which is then exported as an 8-by-8 flipbook texture.</p>
<p><img src="_page_81_Figure_3.jpeg" alt=""></p>
<p>The smoke portal begins as a Houdini simulation.</p>
<p>— <strong>Flames and additional effects:</strong> Flame effects are developed using flipbook textures and blended with the smoke ring for realism. Rocks and sparks are added to the scene, creating a sense of gravitational pull and integrating the effect with the surroundings.</p>
<p><img src="_page_81_Picture_6.jpeg" alt=""></p>
<p>The flames are flipbook textures.</p>
<ul>
<li><strong>Six-way lighting:</strong> The six-way lighting feature uses baked light maps from six different axes. This technique avoids the high computational cost of volumetric rendering by instead using sprites. Real-time lights can interact with the smoke, creating realistic lighting and shadows without a true volumetric render.</li>
<li><strong>Flipbook blending:</strong> Motion vectors help blend the frames of the flipbook. <a href="https://assetstore.unity.com/packages/tools/particles-effects/tflow-201971">TFlow</a> (from Asset Store) helps to generate motion vectors from the exported flipbook textures; when reducing the texture resolution, using the TFlow motion vector map could help compensate for lost quality. Flipbook textures are applied to a parabola-shaped mesh for better volume and integration with the environment.</li>
<li><strong>Procedural crystals:</strong> VFX Graph helps to create varied crystal formations in the surrounding environment. <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Instancing.html">Instancing</a> reduces the computational load by grouping the VFX crystals into single batches.</li>
</ul>
<p><img src="_page_82_Picture_4.jpeg" alt=""></p>
<p>VFX Graph instancing helped optimize the crystal elements.</p>
<p>— <strong>HDRP lighting</strong>: Spotlights provide focused illumination around the flames, while area lights complete the ambient lighting along the path. Dynamic lighting effects add animation to the light positions with a light flicker script to make the scene more life-like. The radius of point lights is kept small to optimize the setup without compromising visual quality.</p>
<p><span id="page-83-0"></span>— <strong>Optimization:</strong> Several strategies improve performance in the VFX Graph. These include reducing the portal&#39;s flipbook texture from 8K to 2K resolution, using alpha clipping to reduce transparent overdraw, and utilizing <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Instancing.html">VFX Graph&#39;s instancing</a> feature for the crystal elements.</p>
<p><img src="_page_83_Figure_2.jpeg" alt=""></p>
<p>The portal combines several techniques into the final effect.</p>
<p>Watch the original <a href="https://www.youtube.com/watch?v=57cKxN3XdEY">breakdown video</a> for more information.</p>
<h4 id="-six-way-lighting-for-real-time-smoke-"><strong>Six-way lighting for real-time smoke</strong></h4>
<p>Rendering realistic smoke in real-time can be a challenge because true volumetric rendering is too expensive for most games. To work around this, many developers use flipbook textures, which typically involves splitting a texture into an n-by-n grid. However, this sacrifices resolution and memory since only a fraction of the resolution is visible at any time.</p>
<p><img src="_page_83_Picture_7.jpeg" alt=""></p>
<p>A common question arises: How do you light the smoke based on flat, 2D geometry? Adding more textures for variety quickly eats up the memory budget, reducing both texture quality and the variety of explosions you can have. Other methods, like normal mapping or fully baked color maps, often aren&#39;t realistic looking or flexible enough.</p>
<p>That&#39;s where six-way lighting comes in. This method allows for smoke rendering from baked simulations and works well across different lighting conditions. It can approximate the volumetric feel of smoke with a cost-effective process.</p>
<p>The secret of six-way lighting lies in using a set of lightmaps that capture how the smoke looks when lit from six different directions (top, bottom, left, right, front, back).</p>
<p>These lightmaps are then baked into two RGBA textures. The first texture&#39;s RGB channels store the top, left, and right maps, while the alpha channel stores the bottom map.</p>
<p><img src="_page_84_Figure_5.jpeg" alt=""></p>
<p>The second texture&#39;s RGB channels store the front, back, and an additional map, with the alpha channel available for an optional emissive mask.</p>
<p>The six lightmaps capture different light directions.</p>
<p>When rendering, the shader blends between the six lightmaps based on the direction of the light relative to each particle. This means the smoke can be dynamically shaded for different lighting conditions, using direct lighting from all light types and indirect lighting from light probes and other global illumination techniques.</p>
<p>Six-way lighting offers these advantages:</p>
<ul>
<li><strong>Complex light interactions and scattering effects:</strong> It simulates realistic light scattering within the smoke, adding visual complexity and making the smoke look more natural.</li>
<li><strong>Improved visual integration with the environment:</strong> The dynamic shading helps the smoke blend with its surroundings, adapting to changing lighting conditions.</li>
</ul>
<p><img src="_page_85_Picture_4.jpeg" alt=""></p>
<p>Six-way lighting enables varied smoke rendering under different lighting conditions.</p>
<ul>
<li><strong>Cost-effective rendering:</strong> Despite its realistic appearance, six-way lighting is performance-friendly and suitable for real-time applications.</li>
<li><strong>Memory efficiency:</strong> By reusing the lightmap textures for different lighting conditions, this method conserves memory compared to having multiple textures for different lighting conditions.</li>
</ul>
<p><span id="page-86-0"></span>Six-way lighting can be a useful technique in your effects toolkit, balancing visual quality, performance, and memory usage for rendering real-time smoke effects.</p>
<p><img src="_page_86_Picture_2.jpeg" alt=""></p>
<p>Watch <a href="https://www.youtube.com/watch?v=uNzLQjpg6UE">VFX Graph: Six-way lighting workflow</a> for a complete walkthrough of the technique. You can also read this <a href="https://unity.com/blog/engine-platform/realistic-smoke-with-6-way-lighting-in-vfx-graph">blog post</a> for more information.</p>
<h4 id="-gooball-"><strong>GooBall</strong></h4>
<p>Have you ever wanted to splatter paint in Unity? This playful sci-fi demo incorporates decals that simulate gooey substances interacting with their surrounding environment. Like other production examples, this multilayered effect leverages several Systems to achieve its final look.</p>
<p><img src="_page_86_Picture_6.jpeg" alt=""></p>
<p>The GooBall effect</p>
<p>The center blob starts with a <strong>Vertex Animation Texture</strong> (VAT) Shader Graph that creates the impression of fluid movement. A scrolling texture sheet in the shader constantly undulates the mesh&#39;s 3D points, which is ideal for sci-fi goo.</p>
<p><img src="_page_87_Figure_2.jpeg" alt=""></p>
<p>The main blob</p>
<p>Because the Shader Graph connects directly to the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Context-OutputParticleMesh.html">Output Particle Lit Mesh Context</a></strong>, there are some input ports that influence the shader. Here&#39;s the VAT Shader Graph at a glance:</p>
<p><img src="_page_88_Figure_2.jpeg" alt=""></p>
<p>The VAT Shader Graph</p>
<p>In addition to the vertex motion, the Shader Graph also creates the appearance of a transparent, green glass-like material. This makes up the goo&#39;s look.</p>
<p>Shader Graph is <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sg-working-with.html">closely integrated</a> with the VFX Graph. In this example, you can edit some of the GooBall&#39;s shading parameters from the VFX Graph&#39;s Blackboard. Go to the <strong>Inspector</strong> to access a unified set of sliders and fields for tweaking the goo&#39;s appearance.</p>
<table>
<thead>
<tr>
<th>▼ Visual Effect</th>
<th></th>
<th>�花 :</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt; General</td>
<td></td>
<td></td>
</tr>
<tr>
<td>► Renderer</td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ Properties</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ද<br>Show Property Gizmos</td>
<td></td>
</tr>
<tr>
<td>√ VAT:Position</td>
<td>METABLOP_VAT-VATPOS</td>
<td>O</td>
</tr>
<tr>
<td>✓ VAT:Normals</td>
<td>METABLOP_VAT-VATNRM</td>
<td>O</td>
</tr>
<tr>
<td>Alpha</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AO</td>
<td></td>
<td>0.889</td>
</tr>
<tr>
<td>MEt</td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Smooth</td>
<td></td>
<td>0.845</td>
</tr>
<tr>
<td>√ EmissiveIntensity</td>
<td>143.4</td>
<td></td>
</tr>
<tr>
<td>✔ RefractionIndex</td>
<td>1.05</td>
<td></td>
</tr>
<tr>
<td>✓ REfractionDistance</td>
<td></td>
<td>- 0.698</td>
</tr>
<tr>
<td>V Thickness</td>
<td></td>
<td></td>
</tr>
<tr>
<td>v Coat</td>
<td></td>
<td>0.211</td>
</tr>
<tr>
<td>&gt; Normal Evaluation distance -- ●</td>
<td></td>
<td>8.8</td>
</tr>
</tbody>
</table>
<p><img src="_page_89_Picture_3.jpeg" alt=""></p>
<p>Adjust the Blackboard properties to modify the goo&#39;s appearance</p>
<p>The main blob triggers a GPU Event to spawn some particles on the surface of a sphere. Downward force is applied with the proper maps and some droplets of goo drip periodically.</p>
<p>Even though the VFX Graph doesn&#39;t directly interact with a Collider on the floor, you can approximate the environment with the Camera&#39;s <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithDepthBuffer.html">depth buffer</a></strong>. This works if precision isn&#39;t a concern.</p>
<p><img src="_page_89_Picture_7.jpeg" alt=""></p>
<p>Visualizing the Camera&#39;s depth buffer</p>
<p><img src="_page_90_Picture_0.jpeg" alt=""></p>
<p>As drops hit the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithDepthBuffer.html">depth buffer</a>, they trigger a GPU Event. This Event passes the position, color, and size Attributes to a separate System for handling the decals.</p>
<p>To orient the splats correctly against the geometry, the buffer&#39;s depth normals are calculated using something like this:</p>
<p><img src="_page_90_Figure_4.jpeg" alt=""></p>
<p>Depth normals</p>
<p>They then pass into the Z axis Attribute so that all the decals face the right way. With the new puddle texture created, each decal splats convincingly across the uneven surface of the floor.</p>
<p><span id="page-91-0"></span><img src="_page_91_Figure_1.jpeg" alt=""></p>
<p>Drops fall off the surface and leave decals.</p>
<p>The scene gets more chaotic with extra projectiles that fire off randomly from the spherical surface. This reiterates the power of VFX.</p>
<h4 id="-physics-based-effects-"><strong>Physics-based effects</strong></h4>
<p>The VFX Graph can compute complex simulations and read frame buffers. However, it does not support bringing particle data into C# or connecting to the underlying physics system.</p>
<p>That&#39;s why you&#39;ll need to use some workarounds to create physics-based effects, such as:</p>
<ul>
<li>The depth buffer</li>
<li>Primitive representations (sphere, box, torus, etc.)</li>
<li>3D textures like <strong>Signed Distance Fields</strong>, <strong>Point Caches</strong>, or <strong>Vector Fields</strong></li>
</ul>
<p><img src="_page_92_Figure_1.jpeg" alt=""></p>
<p>Projectiles firing chaotically from the GooBall</p>
<p>As the projectile collides with the room geometry, a similar technique calculates the splats. This time, though, you should also check if a second Trace decal falls within the height range of the walls. If it does, the Y scale will animate slightly, completing the illusion of the slime slipping down the smooth, metallic surfaces.</p>
<p><img src="_page_93_Figure_1.jpeg" alt=""></p>
<p>Splat and Trace decals complete the effect.</p>
<p>Even if you&#39;re not aiming to reproduce this exact effect, the GooBall scene shows you how to:</p>
<ul>
<li>Incorporate Shader Graph into your Output Context</li>
<li>Use GPU Events to trigger other Systems in the same graph</li>
<li>Apply decals over your environment using depth normals</li>
</ul>
<p><span id="page-94-0"></span><img src="_page_94_Picture_1.jpeg" alt=""></p>
<h4 id="-the-ribbon-pack-"><strong>The Ribbon Pack</strong></h4>
<p>This abstract effect demonstrates the use of <strong>Particle Strips</strong> – that is, chains of particles rendered as lines or strips of quads.</p>
<p>Often, they can simulate animated trails. Guide them with other particles using GPU Events, and notice how every point of a trail evolves independently, allowing you to apply wind, force, and turbulence.</p>
<p><img src="_page_94_Picture_5.jpeg" alt=""></p>
<p>The Ribbon Pack features Particle Strips.</p>
<p><img src="_page_95_Picture_0.jpeg" alt=""></p>
<p>The Ribbon Pack graph spawns multicolored particles on the surface of a spherical arc. Use <strong>Noise</strong> to add some organic motion, or modify the available <strong>Blocks</strong> to customize each Particle Strip&#39;s texture mapping, spawning, and orientation.</p>
<p>If you were to render this effect conventionally with mesh particles, it would resemble something like this:</p>
<p><img src="_page_95_Picture_3.jpeg" alt=""></p>
<p>Rendering the Ribbon Pack without Particle Strips</p>
<p>Instead, the first System is hidden and doesn&#39;t appear onscreen. A <strong>Trigger Event Rate Block</strong> is used to invoke a GPU Event.</p>
<p><img src="_page_95_Figure_6.jpeg" alt=""></p>
<p>The Trigger Event Rate Block invokes a GPU Event.</p>
<p>This sends a message to a series of Contexts that initialize, update, and render the Particle Strips. The result is a prismatic tangle of cables or fibers.</p>
<p><img src="_page_96_Picture_2.jpeg" alt=""></p>
<p>The many ribbons</p>
<p>Particle Strips have numerous applications; think of magical streaks, weapon trails, and wires, to name a few. The Magic Book sample uses Particle Strips for the trails swirling around each beam.</p>
<p><img src="_page_96_Picture_5.jpeg" alt=""></p>
<p>Particle Strip trails in the Magic Book sample</p>
<p>They also stand in for blades of grass in the Meteorite sample, discussed in the section below.</p>
<p><span id="page-97-0"></span><img src="_page_97_Picture_0.jpeg" alt=""></p>
<h4 id="-meteorite-sample-"><strong>Meteorite sample</strong></h4>
<p>The Meteorite sample combines several effects to accentuate the impact of a meteor crashing into the earth. A <strong>MeteoriteControl</strong> script on the <strong>Timeline</strong> object listens for your keypresses or mouse clicks and then activates the meteorite effect.</p>
<p>In this scene, the ground and surrounding trees react to the blast. But don&#39;t worry, no VFX critters were harmed in the making of this effect.</p>
<p><img src="_page_97_Picture_5.jpeg" alt=""></p>
<p>The Meteorite sample</p>
<p>Here, a single graph called <strong>MeteoriteMain</strong> drives several others. The graph itself is neatly organized:</p>
<p><img src="_page_97_Figure_8.jpeg" alt=""></p>
<p>The MeteoriteMain graph</p>
<p><img src="_page_98_Picture_0.jpeg" alt=""></p>
<p>A chain reaction of effects plays every time a meteor drops from the sky. It consists of a central Spawn Context that triggers many other effects:</p>
<ul>
<li>Vibrating rocks and a light effect anticipating the meteor</li>
<li>The crashing meteor, along with smoke trails</li>
<li>A burst of animated light to jolt your viewers on impact</li>
<li>Rigidbody &quot;planks&quot; and debris that interact with the ground</li>
<li>Camera shake to further evoke the force of impact</li>
</ul>
<p><strong>Note</strong>: The MeteoriteMain graph looks relatively clean because much of it is broken into Subgraphs. The Spawn Event plugs directly into many of their Start ports. Drill down into each individual Subgraph to see its specific implementation.</p>
<p>This structure relegates a number of the details into smaller, more manageable parts. It makes the graphs easier to navigate, so you won&#39;t have to wade through a confusing web of nodes.</p>
<p><img src="_page_98_Figure_10.jpeg" alt=""></p>
<p>The Spawn Event plugs into the Subgraphs and Output Events.</p>
<p>Output Events are used to communicate with other components outside of the graph. In particular, the light animation, camera shake, and plank debris have their own Output Events. If you select the GameObject called <strong>VFX_MeteoriteMain</strong>, you&#39;ll see various Output Event Handler scripts that receive these events and respond accordingly.</p>
<table>
<thead>
<tr>
<th>@ Inspector</th>
<th></th>
<th></th>
<th>a :</th>
</tr>
</thead>
<tbody>
<tr>
<td>VFX_MeteoriteMain</td>
<td></td>
<td></td>
<td>- Static ·</td>
</tr>
<tr>
<td>Tag Untagged</td>
<td>▼ Layer Default</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1<br>Transform</td>
<td></td>
<td></td>
<td>0 花 :</td>
</tr>
<tr>
<td>Position</td>
<td>× 0</td>
<td>Y 1.43995</td>
<td>Z O</td>
</tr>
<tr>
<td>Rotation</td>
<td>× 0</td>
<td>Y O</td>
<td>Z O</td>
</tr>
<tr>
<td>Scale</td>
<td>QQ X 1</td>
<td>Y 1</td>
<td>Z 1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Visual Effect</td>
<td></td>
<td></td>
<td>0 2 :</td>
</tr>
<tr>
<td>T General</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Asset Template</td>
<td>% MeteoriteMain</td>
<td></td>
<td>Edit<br>O</td>
</tr>
<tr>
<td>Random Seed</td>
<td>0</td>
<td></td>
<td>Reseed</td>
</tr>
<tr>
<td>Reseed on play</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Initial Event Name</td>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D Renderer</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>▼ Properties</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Show Property Gizmos</td>
<td></td>
<td></td>
</tr>
<tr>
<td>New Color</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V VFX Output Event Cinemachine Camera Shake (Script)</td>
<td></td>
<td></td>
<td>� 花</td>
</tr>
<tr>
<td>V V VFX Output Event Prefab Spawn (Script)</td>
<td></td>
<td></td>
<td>0 花</td>
</tr>
<tr>
<td>Execute In Editor</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Output Event</td>
<td>Buffer</td>
<td></td>
<td></td>
</tr>
<tr>
<td>While previewing Prefats Spawn in editor, some Attribute to preflabs cannot not be executed unless you are running in Play Motie</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Prefab Instances</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Prefab To Spawn</td>
<td>TImpactBuffer</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Instance Count</td>
<td>100</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Parent Instances</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Event Attribute Usage</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Position</td>
<td>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Angle</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Scale</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Lifetime</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Help<br>Spayins prelabiron a managed pol of prefats of given attributes can be caught in prefass by using VFXU.tputEventler schps in the<br>prefab.<br>Attribute Usage:<br>- position : spawns prefab at given position<br>- angle : spawns prefab at given angle<br>- scale : spawns prefab at given scale<br>- lifetime : destroys prefab after given lifetime</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Output Event Handler Multiple RB (Script)</td>
<td></td>
<td></td>
<td>9 花</td>
</tr>
<tr>
<td>V VFX Output Event Prefab Spawn (Script)</td>
<td></td>
<td></td>
<td>网 花</td>
</tr>
</tbody>
</table>
<p>Output Event Handlers on the GameObject</p>
<p>Meanwhile, the graph&#39;s <strong>Buffer Output Event</strong> spawns a Prefab called <strong>ImpactBuffer</strong>, which has its own VFX Graph. It animates ground decals, separated into red, blue, and green color channels. The ImpactBuffer effect looks something like this:</p>
<p><img src="_page_99_Picture_5.jpeg" alt=""></p>
<p>The ImpactBuffer Prefab in red, blue, and green</p>
<p>You only need a 2D recording of it. A separate camera called <strong>Buffer Recorder</strong> looks straight down and generates a render texture called <strong>Meteorite_BufferRender</strong>. This texture buffer then sends data to a separate graph called <strong>GrassStrip</strong>.</p>
<table>
<thead>
<tr>
<th>8<br>BufferRecorder<br>&gt;</th>
<th></th>
<th></th>
<th>Static ▼</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tag Untagged</td>
<td>Layer Default<br>&gt;</td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>4<br>Transform</td>
<td></td>
<td></td>
<td>8 花</td>
</tr>
<tr>
<td>Position</td>
<td>x 0</td>
<td>Y 12.41528</td>
<td>N<br>0</td>
</tr>
<tr>
<td>Rotation</td>
<td>× 90</td>
<td>Y<br>0</td>
<td>N<br>0</td>
</tr>
<tr>
<td>ర్యా<br>Scale</td>
<td>× 1</td>
<td>Y 1</td>
<td>Z 1</td>
</tr>
<tr>
<td>Camera</td>
<td></td>
<td></td>
<td>9<br>14</td>
</tr>
<tr>
<td>► Projection</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>► Rendering</td>
<td></td>
<td></td>
<td>@<br>&quot;</td>
</tr>
<tr>
<td>► Environment</td>
<td></td>
<td></td>
<td>a</td>
</tr>
<tr>
<td>▼ Output</td>
<td></td>
<td></td>
<td>@</td>
</tr>
<tr>
<td>Target Display</td>
<td>Display 1</td>
<td></td>
<td>▶</td>
</tr>
<tr>
<td>Target Texture</td>
<td>网 Meteorite BufferREnder</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Depth</td>
<td>-1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Viewport Rect</td>
<td>× 0</td>
<td>Y O</td>
<td></td>
</tr>
<tr>
<td></td>
<td>W 1</td>
<td>H 1</td>
</tr>
</tbody>
</table>
<p>The BufferRecorder</p>
<p>The texture plugs into the GrassStrip graph, driving the movement and rendering of the Particle Strips. Here you can see how the texture buffer drives the effect:</p>
<p><img src="_page_100_Picture_4.jpeg" alt=""></p>
<p>A texture buffer controls the grass effects.</p>
<p>Beyond the main meteorite, there are some secondary effects, including:</p>
<ul>
<li>Leaves dropping from the trees</li>
<li>Birds scattering in the foreground and background</li>
<li>Butterflies disappearing and reappearing</li>
</ul>
<p>These secondary effects rely on the <strong>Meteorite Timeline</strong>, which contains several <strong>Visual Effect Activation Tracks</strong>. When the MeteoriteControl script kicks off the <strong>Playable Director</strong>, each secondary effect plays back according to its prescribed timing.</p>
<p><span id="page-101-0"></span></p>
<table>
<thead>
<tr>
<th>Timeline</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>a :</th>
</tr>
</thead>
<tbody>
<tr>
<td>Preview   NA<br>ﺍﻟ<br>A<br>0 2) 2 2 14 14</td>
<td></td>
<td></td>
<td></td>
<td>T MeteoriteTimeline (Timeline)</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>ಿ</td>
</tr>
<tr>
<td>+▼<br>ব</td>
<td>→</td>
<td>141</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>, 10, 20, 10, 10, 20, 10, 20, 10, 10, 120, 10, 120, 10, 10, 150, 160, 150, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>× Markers</td>
<td></td>
<td></td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0<br>&gt; Timeline (Animator)</td>
<td>◎</td>
<td>平台 ◎ :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VEXG_MeteoriteMain (Visual Effect)</td>
<td>の</td>
<td>平台 © :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VFX_Leaves (Visual Effect)</td>
<td>の</td>
<td>平台 ● 注</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Visual Effect) (Visual Effect)</td>
<td>の</td>
<td>平台 ● :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VFX_StaticBird (Visual Effect)</td>
<td>⊙</td>
<td>平台 @ :</td>
<td></td>
<td>VisualEf</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ك VFX_StaticBird (1) (Visual Effect)<br>2</td>
<td>⊙</td>
<td>平台 ◎ :</td>
<td></td>
<td>VisualEf</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>VFX_Butterfly (Visual Effect)</td>
<td>の</td>
<td>平台◎ :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
</tr>
<tr>
<td>STREES (Visual Effect)</td>
<td>の</td>
<td>平台 @ :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>LightFlashFX (Visual Effect)</td>
<td>の</td>
<td>平台 @ :</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>VisualEffectActivationClip</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The Meteorite Timeline</p>
<p>See the <a href="#page-123-0">Interactivity</a> chapter for more information on how to set up Timeline and Output Events.</p>
<p><img src="_page_101_Figure_4.jpeg" alt=""></p>
<h4 id="-mesh-sampling-effects-"><strong>Mesh sampling effects</strong></h4>
<p>Mesh sampling is an experimental technique that lets you fetch data from a mesh and use the result in the graph. Sample a mesh with either the:</p>
<ul>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetPosition(Mesh">Position (Mesh) Block</a>.html)</li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-SampleMesh.html">Sample Mesh Operator</a></li>
</ul>
<p><img src="_page_102_Picture_1.jpeg" alt=""></p>
<p><img src="_page_102_Picture_2.jpeg" alt=""></p>
<p>Sample Mesh Operator and Position (Mesh) Block</p>
<p>The <strong>Placement Mode</strong> can be set to <strong>Vertex</strong>, <strong>Edge</strong>, or <strong>Surface</strong>. Here&#39;s the <strong>Position (Mesh) Block</strong> at work on some simple meshes:</p>
<p><img src="_page_102_Figure_7.jpeg" alt=""></p>
<p>Vertex, Surface, or Edge sampling</p>
<p>This variation modifies the original Magic Lamp scene from the samples. With some additional work, you can use the <strong>Sample Mesh Operator</strong> to initialize particles on the lamp&#39;s surface and change their orientation as they float away. Grab the Magic Lamp&#39;s <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-SampleTexture2D.html">Sample Texture</a></strong> to smoothly integrate the particle colors with the mesh surface.</p>
<p><img src="_page_103_Figure_2.jpeg" alt=""></p>
<p>Magic Lamp sample scene</p>
<p><span id="page-104-0"></span><img src="_page_104_Picture_0.jpeg" alt=""></p>
<h4 id="skinned-mesh-sampling">Skinned Mesh sampling</h4>
<p>Applying effects to your characters in a game can add fun and eye-catching elements to the gameplay. Do you need a vampire to disintegrate after being staked through the heart? Or to burst into flames? By sampling a <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-SkinnedMeshRenderer.html">Skinned Mesh Renderer</a>, either option is possible.</p>
<p>The sample effect called <strong>EllenSkinnedMeshEffects</strong> illustrates a variety of effects involving its title heroine. However, the general process for sampling skinned mesh data is similar in each case:</p>
<ul>
<li>Add a <strong>Position (Skinned Mesh) Block</strong> to a <strong>Context</strong> (<strong>Initialize</strong>, <strong>Update</strong>, or <strong>Output</strong> depending on your intended effect).</li>
<li>Expose a <strong>Skinned Mesh Renderer</strong> property on the <strong>Blackboard</strong>, and connect it to the Skinned Mesh flow port.</li>
<li>Use a <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Operator-SampleMesh.html">Skinned Mesh Operator</a></strong> if you need additional access to <strong>Surface</strong>, <strong>Edge</strong>, or <strong>Vertex</strong> data (see the Hologram and Disintegration graphs for example usage).</li>
</ul>
<p><img src="_page_104_Figure_7.jpeg" alt=""></p>
<p>Setting up the Position (Skinned Mesh) in the graph</p>
<p><img src="_page_105_Picture_0.jpeg" alt=""></p>
<ul>
<li>In the <strong>Inspector</strong>, set the <strong>Property</strong> with a <strong>Skinned Mesh Renderer</strong> from your scene.</li>
<li>Use a <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/PropertyBinders.html">Property Binder</a></strong> (se<a href="#page-123-0">e Interactivity chapter</a>) to transform the effect&#39;s position and orientation in your character&#39;s skeleton. Set this <strong>Transform</strong> and its corresponding <strong>Set Position Block</strong> to <strong>World</strong> space for optimal results.</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>V Visual Effect</th>
<th>9 元 :</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>V General</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Asset Template</td>
<td>Edit<br># ElectricitySampling<br>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Random Seed</td>
<td>Reseed<br>O</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Reseed on play</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Initial Event Name</td>
<td>OnPlay</td>
<td></td>
</tr>
<tr>
<td></td>
<td>▼ Renderer</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>v Probes</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Light Probes</td>
<td>Off</td>
<td></td>
</tr>
<tr>
<td></td>
<td>▼ Additional Settings</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Select from</td>
<td>Rendering Layer Mask</td>
<td>0: Light Layer default, 8: Decal Layer default<br>0</td>
<td></td>
</tr>
<tr>
<td>Hierarchy</td>
<td>Priority<br>Sorting Layer</td>
<td>Default</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Order in Layer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>&#39; Hierarchy</td>
<td>▼ Properties</td>
<td></td>
<td></td>
</tr>
<tr>
<td>+▼</td>
<td></td>
<td>A   Show Property Gizmos</td>
<td></td>
</tr>
<tr>
<td>EllenSkinnedMeshEffects<br>C Main Camera</td>
<td>Count</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>&gt; ScreenFade</td>
<td>V New SkinnedMeshRenderer</td>
<td>ര Ellen_Body (Skinned Mesh Renderer)<br>0</td>
<td>Skinned Mesh GameObject</td>
</tr>
<tr>
<td>LENVIRONMENT<br>EFFECTS</td>
<td>Root Transform</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CO TIMELINE</td>
<td>v position</td>
<td>X 1.197928e -: Y 0.8400196 Z 0.0275007</td>
<td></td>
</tr>
<tr>
<td>v A Ellen<br>C Ellen_Body</td>
<td>V angles</td>
<td>× 7<br>Y O<br>270<br>N</td>
<td></td>
</tr>
<tr>
<td>Ellen_Controllers</td>
<td>✔ scale</td>
<td>Y 1.000021<br>Z 1.000021<br>× 1</td>
<td></td>
</tr>
<tr>
<td>▼ ( Ellen_Skeleton<br>TM Ellen Root</td>
<td>V V VFX Property Binder (Script)</td>
<td>0 % !</td>
<td></td>
</tr>
<tr>
<td>T Ellen Hips<br>&gt; Ellen_Left_Upper Leg</td>
<td>Execute In Editor</td>
<td>&gt;</td>
<td></td>
</tr>
<tr>
<td>&gt; ( ) Ellen_Right_UpperLeg<br>I&gt; Ellen_Spine</td>
<td>Property Bindings</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Reflection Probe</td>
<td>Transform : &#39;Root Transform&#39; -&gt; Ellen_Hips</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>+ -</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Property</td>
<td>Root Transform</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Target</td>
<td>O<br>JA Ellen_Hips (Transform)</td>
<td>Root Transform</td>
</tr>
</tbody>
</table>
<p>Set the Properties and VFX Property Binder</p>
<p>You&#39;ll also need to add a <strong>Mesh Transform Property Binder</strong> that accounts for the <strong>Base Transform</strong> of the skeleton itself.<sup>1</sup> This varies from character to character, but in this case, it connects the character&#39;s hip joint. Now the particles can follow the Skinned Mesh Renderer.</p>
<p><img src="_page_105_Picture_8.jpeg" alt=""></p>
<p>The EllenSkinnedMeshEffects example</p>
<p>1 Unity 2021 LTS is shown here. This step is not necessary in Unity 2022.2 or newer.</p>
<p><span id="page-106-0"></span><img src="_page_106_Picture_0.jpeg" alt=""></p>
<p>Leverage Skinned Mesh sampling&#39;s versatility when creating effects for characters and objects alike. In the samples, the Ellen character is shown:</p>
<ul>
<li>As a sci-fi holographic projection</li>
<li>On fire, with smoke and sparks</li>
<li>Wet, with water droplets trailing from her skin</li>
<li>Dashing at super speed, with colored streaks left behind</li>
<li>Jolted by electricity</li>
<li>Turning into ashes</li>
</ul>
<p>Each of these is a separate graph that samples a Skinned Mesh Renderer. You can examine their implementation details to see how the particles interact with the character mesh.</p>
<h4 id="-more-examples-"><strong>More examples</strong></h4>
<p>There are many more possibilities you can explore with the VFX Graph Samples. Be sure to check out the other scenes in the project; each one demonstrates a different set of techniques for creating a specific visual effect.</p>
<h2 id="-span-id-page-107-0-span-render-pipelines-and-vfx-graph"><span id="page-107-0"></span>Render pipelines and VFX Graph</h2>
<p>Your choice of render pipeline affects the available output Contexts in VFX Graph. Your design needs and target platform will ultimately determine which render pipeline is most suitable for your application.</p>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/urp-introduction.html">Universal Render Pipeline (URP)</a> is optimized for performance across a wide range of devices, from low-end mobile to high-end consoles and PCs. It provides a streamlined feature set with simplified lighting and single-pass forward rendering. URP supports VFX Graph, though some advanced features may be limited or unavailable.</p>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">High Definition Render Pipeline (HDRP)</a> is optimized for high-end PCs and consoles, using a deferred rendering path to handle complex lighting and shading. HDRP includes advanced features like ray tracing, volumetric lighting, subsurface scattering, and screen-space reflections. However, HDRP&#39;s higher performance overhead and limited platform support make it less suitable for low-end devices and mobile platforms.</p>
<p>You can visit the full render pipeline feature comparison <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/render-pipelines-feature-comparison.html#visual-effects">here.</a></p>
<p><span id="page-108-0"></span><img src="_page_108_Picture_0.jpeg" alt=""></p>
<p><img src="_page_108_Picture_2.jpeg" alt=""></p>
<h4 id="-device-support-"><strong>Device support</strong></h4>
<p>The VFX Graph requires compute shaders for device compatibility. Compute support on mobile devices varies widely across brands, mobile GPU architecture, and operating systems. Unity&#39;s <a href="https://docs.unity3d.com/Manual/ParticleSystems.html">Built-In Particle System</a> is recommended if your platform does not support compute shaders.</p>
<p>For detailed render pipeline compatibility, please refer to the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/System-Requirements.html">Unity VFX Graph System</a>  <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/System-Requirements.html">Requirements</a>.</p>
<h3 id="vfx-graph-for-urp">VFX Graph for URP</h3>
<p>VFX Graph supports the Universal Render Pipeline for a range of compute-capable desktop, mobile, and XR platforms. Note: In URP, the Visual Effect Graph doesn&#39;t support <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/set-project-color-space.html">gamma color</a>  <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/set-project-color-space.html">space</a>.</p>
<p>Unity 6 has added support for several features in the Universal Render Pipeline (URP) that were previously available only in HDRP.</p>
<h4 id="-lit-output-"><strong>Lit output</strong></h4>
<p>VFX Graph now supports Lit outputs in URP. Use them to create effects that respond directly to the scene&#39;s lighting.</p>
<p><span id="page-109-0"></span><img src="_page_109_Picture_1.jpeg" alt=""></p>
<p>URP support now includes Lit outputs.</p>
<p>You can now spawn URP decals with VFX Graph and use Shader Graph to customize decals for both HDRP and URP.</p>
<h4 id="-2d-renderer-and-shader-graph-support-"><strong>2D Renderer and Shader Graph support</strong></h4>
<p>VFX Graph supports Shader Graph&#39;s 2D sub-targets that you can use to render your particles as sprites. To find the new sub-targets, go to <strong>Create &gt; Shader Graph &gt; URP</strong>. This feature is exclusive to the Universal Render Pipeline.</p>
<p><img src="_page_109_Picture_6.jpeg" alt=""></p>
<p>VFX Graph Rain effects with the URP 2D Renderer</p>
<p><span id="page-110-0"></span><img src="_page_110_Picture_0.jpeg" alt=""></p>
<h4 id="-decals-"><strong>Decals</strong></h4>
<p>Spawn URP decals with VFX Graph and customize them with Shader Graph for both HDRP and URP. Use them to add bullet impacts, footprints, surface damage, or any other dynamic effects to the environment.</p>
<h4 id="-six-way-smoke-lighting-"><strong>Six-way smoke lighting</strong></h4>
<p>Six-way lighting for realistic smoke effects is customizable with lightmaps from tools like Houdini by SideFX, Blender, or EmberGen by JangaFX. This lighting technique allows your smoke particles to approximate volumetric smoke with dynamic real-time lighting without the high-computational cost. Use six-way lighting for fire, explosions, or other smoke-like effects, where scene lighting can help integrate the particle simulation into the environment.</p>
<h4 id="-motion-vectors-"><strong>Motion vectors</strong></h4>
<p>VFX Graph particles can generate motion vectors in URP, useful for effects like Temporal Anti-Aliasing (TAA) or Motion Blur. Note that URP only supports opaque particles, while both transparent and opaque are available in HDRP.</p>
<h4 id="-camera-buffer-"><strong>Camera buffer</strong></h4>
<p>You can now sample URP camera buffers to obtain the scene&#39;s depth and color. This feature allows you to perform fast <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CollideWithDepthBuffer.html">collision on the GPU</a> or to <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetPosition(Depth">spawn particles against the depth buffer</a>.html) and inherit the scene color. For instance, you can create VFX impacts and splats, a character dissolving into particles, or effects that change color based on the underlying objects.</p>
<p><img src="_page_110_Picture_10.jpeg" alt=""></p>
<p><img src="_page_110_Picture_11.jpeg" alt=""></p>
<p>The Camera buffer can perform collisions on the GPU.</p>
<p><span id="page-111-0"></span><img src="_page_111_Picture_0.jpeg" alt=""></p>
<h2 id="vfx-graph-for-hdrp">VFX Graph for HDRP</h2>
<p>Some VFX Graph features, such as ray tracing and volumetric rendering, are only available for HDRP. If your application requires high-end graphics, consider the following HDRP-only capabilities.</p>
<h4 id="-ray-tracing-support-"><strong>Ray tracing support</strong></h4>
<p>Use VFX Graph particles with the following ray tracing features in the High Definition Render Pipeline:</p>
<ul>
<li><strong>Ray traced reflections:</strong> This can use offscreen data for more accurate reflections, as an alternative to <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Override-Screen-Space-Reflection.html">Screen Space Reflection.</a></li>
<li><strong>Ray traced shadows:</strong> Ray tracing can replace traditional shadow maps for more accurate and realistic shadows.</li>
<li><strong>Ray traced ambient occlusion:</strong> This is an alternative to HDRP&#39;s screen space ambient occlusion, with a more accurate ray traced solution that can use off-screen data.</li>
<li><strong>Ray traced global illumination:</strong> This is a more accurate representation of indirect light, accounting for light bouncing off surfaces.</li>
</ul>
<p>RTX support adds the ability to render VFX in ray tracing passes to enable taking VFX into account in ray traced reflections.</p>
<p><img src="_page_111_Picture_11.jpeg" alt=""></p>
<p>RTX support adds the ability to render VFX Graphs in ray tracing passes.</p>
<p>You can enable ray tracing with VFX Graphs that use quads, triangles, and octagons. VFX Graph does not support ray tracing with meshes or strips.</p>
<p>To use ray tracing in an HDRP scene, refer to <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@15.0/manual/Ray-Tracing-Getting-Started.html">Getting started with ray tracing</a>.</p>
<p><span id="page-112-0"></span><img src="_page_112_Picture_0.jpeg" alt=""></p>
<h4 id="-volumetric-fog-output-"><strong>Volumetric Fog output</strong></h4>
<p>The <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Context-OutputParticleHDRPVolumetricFog.html">Output Particle HDRP Volumetric Fog</a> output node samples <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/local-volumetric-fog-volume-reference.html">Local Volumetric Fog</a> in HDRP. Use this to simulate dynamic clouds, smoke, and fire effects or to make Volumetric Fog more dynamic.</p>
<p><img src="_page_112_Picture_4.jpeg" alt=""></p>
<p>HDRP supports Volumetric Fog output.</p>
<p>For more details on render pipeline compatibility with VFX Graph, visit the Unity <a href="https://unity.com/roadmap/unity-platform/rendering-visual-effects">Graphics</a>  <a href="https://unity.com/roadmap/unity-platform/rendering-visual-effects">product roadmap</a>.</p>
<h2 id="-span-id-page-113-0-span-shader-graph-integration"><span id="page-113-0"></span>Shader Graph integration</h2>
<p>Visual effects often defy the rules of the real world, requiring unique shading and rendering beyond what standard URP and HDRP shaders offer. Sci-fi force fields or magical auras lack real-world counterparts; thus, the pre-built shaders might be inadequate to describe them. For these scenarios, you can customize shaders using <a href="https://docs.unity3d.com/Packages/com.unity.shadergraph@17.0/manual/Getting-Started.html">Shader Graph.</a></p>
<p>One of the key advantages of Shader Graph integration is the ability to drive shader behavior on a per-particle level. This allows for creating variations, color randomization, and other dynamic effects with different per-particle values, enabling highly complex visuals.</p>
<h2 id="built-in-outputs">Built-in Outputs</h2>
<p>Before diving into custom shaders, be aware that Unity provides a variety of built-in Output Contexts optimized for different render pipelines, including:</p>
<ul>
<li><strong>HDRP/URP Lit Output:</strong> This output is optimized for rendering particles with realistic lighting and shading. Lit Outputs are useful in scenarios where the visual effect needs to react to the lighting in the scene.</li>
<li><strong>Unlit Output:</strong> Designed for simple, non-lit effects, this output does not interact with scene lighting. Use this for stylized or 2D-like effects where lighting calculations are unnecessary.</li>
<li><strong>Six-Way Smoke Lit:</strong> This is a Material Type option for HDRP Lit and URP Lit Outputs. Using this output supports the <a href="https://unity.com/blog/engine-platform/realistic-smoke-with-6-way-lighting-in-vfx-graph">six-way lighting technique</a> to achieve realistic, volumetric-like shading.</li>
</ul>
<p><span id="page-114-0"></span><img src="_page_114_Picture_0.jpeg" alt=""></p>
<ul>
<li><strong>HDRP Distortion Output:</strong> This HDRP output creates effects that warp or distort the background, simulating phenomena like heat haze, water ripples, or glass refraction.</li>
<li><strong>Decals Output:</strong> Used for projecting textures onto surfaces in your scene, this output for URP and HDRP allows you to add details like bullet holes, graffiti, or surface wear directly onto existing geometry</li>
</ul>
<p>These outputs come with integrated shader functionality, including features like frame blending, UVs flipbook, emissive properties, and more. This allows you to create sophisticated effects without needing to build custom shaders from scratch.</p>
<h3 id="shader-effects">Shader effects</h3>
<p>Shader Graph enables technical artists to build custom shading with a graph network. Though Shader Graph and shader authoring are entire subtopics unto themselves, a working knowledge of shaders can complement your usage of VFX Graph. Shaders allow you to manipulate light and color to give your effects an added boost.</p>
<p>With Shader Graph, you can warp and animate UVs or procedurally alter a surface&#39;s appearance. Shaders can act like fullscreen image filters or be useful for changing an object&#39;s surface based on world location, normals, distance from the camera, etc. The visual interface of Shader Graph helps you iterate more quickly with real-time feedback.</p>
<p><img src="_page_114_Picture_8.jpeg" alt=""></p>
<p>Shaders can use UVs to alter a surface&#39;s appearance.</p>
<p>Shaders can be used to create dynamic effects like fire that flickers or water that reacts to objects moving through it. For natural phenomena like clouds, smoke, and fluids, shaders can help create intricate and non-repetitive patterns, adding depth and variation.</p>
<p><img src="_page_115_Picture_2.jpeg" alt=""></p>
<p><img src="_page_115_Picture_3.jpeg" alt=""></p>
<p>Shader Graph integration with HDRP</p>
<p>Here are some other ways shaders can complement your VFX Graphs:</p>
<ul>
<li><strong>Distortion effects:</strong> Shaders can manipulate pixels to simulate the refraction of light. Use a distortion shader to create a wavy effect over a heat source like a bonfire or jet engine. Distortion can also imitate the appearance of ripples in water or another liquid.</li>
<li>For example, the Portal effect from the <a href="https://github.com/Unity-Technologies/VisualEffectGraph-Samples">Visual Effect Graph Samples</a> uses a Shader Graph to distort the center of the portal interior.</li>
</ul>
<p><img src="_page_116_Picture_1.jpeg" alt=""></p>
<p>Shading can simulate light refraction.</p>
<p>— <strong>Alpha erosion:</strong> Dissolving an object or texture is a common way to fade textures in and out non-uniformly, creating the effect of something vanishing into smoke or ash, or revealing a hidden structure. Think teleportation, holograms, or anything else that disintegrates.</p>
<p>In the Magic Book sample, for instance, a specialized shader makes the flying pages appear to dissolve into embers.</p>
<p><img src="_page_116_Picture_5.jpeg" alt=""></p>
<p>Shaders can create a dissolving effect.</p>
<p>— <strong>Vertex animation:</strong> Simulate organic movement or dynamic surfaces with vertex animation. Vertex shaders can move mesh vertices to create animations directly on the GPU. For example, make one mesh morph into another, bend a particle strip into an arc, or make a surface undulate like a waving flag or the tail of a fireball.</p>
<p><img src="_page_117_Picture_2.jpeg" alt=""></p>
<p>Vertex animation can simulate organic movement.</p>
<p>— <strong>Lighting and shading:</strong> Add realism or stylization through advanced lighting effects. VFX Graphs often benefit from glowing shaders or complex lighting interactions, such as reflections, refractions, and shadows.</p>
<p>For instance, if you have a magic effect that imitates glass, water, or metal, your shader will need to simulate accurate reflections. Making a toon shaded game? Shader Graph can help you render stylized anime-like effects.</p>
<p>In this example, the darts are particles that use a Shader Graph to render the lit meshes like springy projectiles.</p>
<p><img src="_page_118_Figure_5.jpeg" alt=""></p>
<p>Shading enhances the mesh particles.</p>
<p>— <strong>Color transitions:</strong> Shaders can interpolate colors based on time, position, or user input. Use a ramp or gradient to transition colors smoothly across a surface or through an animation sequence. Make your effects more dynamic, such as a flame shifting from a hot blue core to red and yellow outer layers.</p>
<p><img src="_page_119_Picture_2.jpeg" alt=""></p>
<p>Color transitions can make the effect more dynamic.</p>
<p>— <strong>Blending masks and transparency:</strong> Effects requiring varying levels of transparency can benefit from custom shading. Use a Shader Graph to control the alpha value of pixels. Blending masks can fade based on height, angle, or distance to camera. This technique is also useful for glass, ice, or anything that needs to transmit light.</p>
<p><img src="_page_119_Picture_5.jpeg" alt=""></p>
<p>Blending masks can fade based on distance or angle.</p>
<p>— <strong>Particle shading:</strong> Shaders can add complexity to particle effects by adding small visual details or manipulating their appearance based on various parameters. For example, use a Shader Graph to control the color, size, and brightness of particles in fireworks. Or apply shaders to make magic spells change color or animate their light emission.</p>
<p><img src="_page_120_Picture_2.jpeg" alt=""></p>
<p>Shaders can make particles change color or animate.</p>
<p>— <strong>Procedural patterns and textures:</strong> Shaders can generate textures procedurally, eliminating the need for pre-made textures. This can reduce the need for large texture files and can create unique patterns while reducing memory usage. Because the textures are based on mathematical functions, they can provide detail without pixelation or blurring, even when close to the camera.</p>
<p><img src="_page_120_Picture_5.jpeg" alt=""></p>
<p>Shaders can generate textures and patterns procedurally.</p>
<h2 id="-span-id-page-121-0-span-shader-graph-and-vfx-graph"><span id="page-121-0"></span>Shader Graph and VFX Graph</h2>
<p>When creating a new Shader Graph, check the <strong>Support VFX Graph</strong> option and then assign it to the corresponding field in the VFX Graph&#39;s Output. This lets you keep your shading and VFX parameters together.</p>
<table>
<thead>
<tr>
<th></th>
<th>@ New Shader Graph*</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>참 ▼</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Color Mode <None></td>
<td>▼ &lt;&lt;&gt;</td>
<td>0 9 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Graph Inspector</td>
<td></td>
<td></td>
<td></td>
<td>Vertex</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Node Settings Graph Settings</td>
<td></td>
<td></td>
<td></td>
<td>Object Space · · O Position(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Precision</td>
<td>Single</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Target Settings</td>
<td></td>
<td></td>
<td></td>
<td>Object Space · O Normal(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Active Targets</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Universal</td>
<td></td>
<td></td>
<td></td>
<td>Object Space · · O Tangent(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>V Universal</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Material</td>
<td>Lit</td>
<td>&gt;</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Allow Material Override</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Workflow Mode</td>
<td>Metallic</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Surface Type</td>
<td>Opaque</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Render Face</td>
<td>Front</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Depth Write</td>
<td>Auto</td>
<td>D</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Depth Test</td>
<td>LEqual</td>
<td>&gt;</td>
<td></td>
<td>Fragment</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Alpha Clipping</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Cast Shadows<br>Receive Shadows</td>
<td>&gt;<br>&gt;</td>
<td></td>
<td></td>
<td>· O Base Color(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Supports LOD Cross Fade</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Additional Motion Vectors</td>
<td>None</td>
<td>▶</td>
<td></td>
<td>Tangent Space · O Normal (Tangent Space)(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Alembic Motion Vectors</td>
<td></td>
<td></td>
<td>× 0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Fragment Normal Space</td>
<td>Tangent</td>
<td></td>
<td></td>
<td>· C Metallic(1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Clear Coat</td>
<td></td>
<td></td>
<td>X 0.5</td>
<td>· O Smoothness(1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Custom Editor GUI</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Support VFX Graph</td>
<td>D</td>
<td></td>
<td>HDR</td>
<td>· O Emission(3)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Enable VFX Graph</td>
<td></td>
<td></td>
<td>× 1</td>
<td>9 Ambient Occlusion(1)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>support</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Enable support for VFX Graph in the shader.</p>
<p>VFX Graph now includes integration with Shader Graph keywords. This allows you to create one Shader Graph for use in multiple VFX Graphs. Then, enable features based on those keywords in the VFX Graph Out Particle Mesh node.</p>
<table>
<thead>
<tr>
<th>VFX Graph Output</th>
<th>Shader Graph keyword</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Graph Inspector</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Node Settings Graph Settings</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Keyword: OptionalColor</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Name<br>OptionalColor<br>Reference<br>_OPTIONALCOLOR<br>Definition<br>ShaderFeature</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>* Output Particle Shader Graph &amp; Local<br>Mesh - Lit</td>
<td>Is Overridable<br>Generate Material Property<br>&gt;<br>All<br>Stages<br>Default Value<br>Option1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Entry Name<br>Reference Suffix</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Graph<br>New Shader Graph (Shader Graph O</td>
<td>Option1<br>OPTION1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Q Mesh<br>出 Cube<br>O</td>
<td>Option2<br>OPTION2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O Sub Mesh Mask</td>
<td>Option3<br>OPTION3<br>Entries</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Option1<br>· Value</td>
<td>Green<br>GREEN</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V Option1<br>Press spac</td>
<td>RED<br>Red</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Option2</td>
<td>BLUE<br>Blue</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Option3<br>Green</td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Red<br>Blue</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The VFX Graph can enable behavior based on Shader Graph keywords.</p>
<p><span id="page-122-0"></span>You can explore examples in both the VFX Graph Learning Templates or look for more general examples in the Shader Graph Feature Examples available in the Package Manager.</p>
<h4 id="shader-graph-feature-examples">Shader Graph Feature Examples</h4>
<p>The <a href="https://unity.com/blog/engine-platform/shader-graph-feature-examples-2022-lts">Shader Graph Feature Examples</a> sample content is a collection of Shader Graph assets that demonstrate how to achieve common techniques and effects in Shader Graph. The goal of this sample pack is to help users see what is required to achieve specific effects and provide examples to make it easier to learn.</p>
<p><img src="_page_122_Picture_4.jpeg" alt=""></p>
<p>Explore the Shader Graph Feature Examples.</p>
<h2 id="-span-id-page-123-0-span-interactivity"><span id="page-123-0"></span>Interactivity</h2>
<p>Visual effects often involve many moving pieces. Connecting them to the correct points in your application is essential to integrating them at runtime.</p>
<p>Whether you need a projectile to explode on contact or bolts of electricity to jump from the mouse pointer, one of these available tools can help them interact with the rest of your Unity scene.</p>
<ul>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/EventBinders.html">Event Binders</a></strong>: These listen for several different things that happen in your scene and react to specific actions at runtime.</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Timeline.html">Timeline</a></strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Timeline.html">:</a> You can sequence visual effects with Activation Tracks to send events to your graph at select moments. Gain precise control with pre-scripted timing (e.g., playing effects during a cutscene).</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/PropertyBinders.html">Property Binders</a></strong>: These link scene or gameplay values to the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Blackboard.html">Exposed properties</a> on your Blackboard so that your effects react to changes in the scene, in real-time.</li>
<li><strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/OutputEventHandlers.html">Output Events:</a></strong> Use these for sending messages from the VFX Graph to scripts or other scene components.</li>
</ul>
<p>Let&#39;s explore each of these tools in more detail as they are crucial techniques for bridging your GameObjects with VFX Graphs.</p>
<h3 id="event-binders">Event Binders</h3>
<p>Event Binders are <strong>MonoBehaviour</strong> scripts that can invoke <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html">Events</a> from within the VFX Graph. They ensure that your effects react to mouse actions, collisions, triggers, and visibility events in the scene.</p>
<h4 id="-span-id-page-124-0-span-onplay-and-onstop-events-"><span id="page-124-0"></span><strong>OnPlay and OnStop Events</strong></h4>
<p>By default, a Spawn Context in the VFX Graph includes an OnPlay or OnStop Event. The Start and Stop flow slots in each Spawn Context receive these implicitly if you don&#39;t plug in a specific Event.</p>
<p><img src="_page_124_Picture_3.jpeg" alt=""></p>
<p>OnPlay and OnStop implicitly flow into the Spawn Context.</p>
<p>If you&#39;re familiar with the GameObject playback controls in the Scene view, the <strong>Play()</strong> and <strong>Stop()</strong> buttons at the bottom send the OnPlay and OnStop Events, respectively.</p>
<table>
<thead>
<tr>
<th></th>
<th>Visual Effect<br>00</th>
<th>DI</th>
<th>L</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Rate</td>
<td>100</td>
<td>Set -</td>
</tr>
<tr>
<td></td>
<td>Show Bounds</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Show Event Tester</td>
<td></td>
<td>V</td>
</tr>
<tr>
<td></td>
<td>Play()</td>
<td>Stop()</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Gizmos</td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>- Visual Effect Event Tester</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Event Attributes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>List is Empty</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>Play</td>
<td>Stop</td>
<td>Custom</td>
<td></td>
</tr>
<tr>
<td>Custom Event</td>
<td>CustomPlayEvent</td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Play and Stop buttons to send the OnPlay and OnStop Events.</p>
<p>Events facilitate the process of sending messages between objects. In the VFX Graph, Events pass as strings. Pressing OnPlay or OnStop doesn&#39;t change the effect immediately, especially compared to using the playback icons at the top. They simply provide signals to the Spawn system.</p>
<p><span id="page-125-0"></span>If you open the dialog window <strong>Visual Effect Event Tester</strong>, you can use the Play and Stop buttons for the same effect. Take advantage of this flexibility to specify a <strong>Custom Event</strong> and invoke it with the Custom button.</p>
<table>
<thead>
<tr>
<th>Visual Effect Event Tester</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Event Attributes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>List is Empty</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>Play</td>
<td>Stop</td>
<td>Custom</td>
</tr>
<tr>
<td>Custom Event</td>
<td>CustomPlayEvent</td>
</tr>
</tbody>
</table>
<p>The Visual Effect Event Tester</p>
<p>Add your own Event to the graph using <strong>Node &gt; Context &gt; Event</strong>. Press the <strong>Send</strong> button to raise the Event manually when testing.</p>
<p>Creating Custom Events is a matter of changing the <strong>Event Name</strong> string and invoking the Event with an <strong>Event Binder</strong> or <strong>Timeline Activation Clip</strong> at runtime.</p>
<p>In this example, two Events called <strong>CustomPlay</strong> and <strong>CustomStop</strong> have been added:</p>
<p><img src="_page_125_Figure_7.jpeg" alt=""></p>
<p>How to set up Custom Events in your graph</p>
<h4 id="-mouse-event-binder-"><strong>Mouse Event Binder</strong></h4>
<p>Clicking, hovering, or dragging a mouse pointer can send messages to your graph using a VFX Mouse Event Binder. This only requires a GameObject with a Collider.</p>
<p>In the example, two Event Binders connect the <strong>CustomPlay Event</strong> and <strong>CustomStop Event</strong> to the Bonfire effect.</p>
<p><span id="page-126-0"></span><img src="_page_126_Picture_1.jpeg" alt=""></p>
<p>Activating an effect with a Mouse Event Binder</p>
<p>If the mouse pointer enters the Collider onscreen, send the CustomPlay Event to the graph. This Event begins spawning the flames, smoke, and sparks. If the mouse pointer exits, the CustomStop Event notifies the Spawn Context to stop.</p>
<p><img src="_page_126_Picture_4.jpeg" alt=""></p>
<p>The mouse pointer raises Events when entering and exiting the Collider.</p>
<p>You can bind Events to any standard mouse actions (<strong>Up</strong>, <strong>Down</strong>, <strong>Enter</strong>, <strong>Exit</strong>, <strong>Over</strong>, or <strong>Drag</strong>). The <strong>Raycast Mouse Position</strong> option passes the pointer&#39;s 3D location as an <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html">Event Attribute</a>.</p>
<h4 id="-rigidbody-collision-event-binders-"><strong>Rigidbody Collision Event Binders</strong></h4>
<p>A Rigidbody Collision Event Binder enables a physics object to alert the graph when a collision occurs. Attach it to any suitable GameObject with a <strong>Rigidbody</strong> and <strong>Collider</strong>.</p>
<table>
<thead>
<tr>
<th>0<br>V<br>Rigidbody</th>
<th></th>
<th>0</th>
<th>北</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Mass</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Drag</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Angular Drag</td>
<td>0.05</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Use Gravity</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Is Kinematic</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Interpolate</td>
<td>None</td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Collision Detection</td>
<td>Continuous</td>
<td></td>
<td></td>
<td>D</td>
</tr>
<tr>
<td>Constraints</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>► Info</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>V VFX Rigid Body Collision Event Binder (Script)<br>V</td>
<td></td>
<td>0</td>
<td>北</td>
<td></td>
</tr>
<tr>
<td>Script</td>
<td>VFXRigidBodyCollisionEventBinder</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Target</td>
<td>&amp; Bonfire (Visual Effect)</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Event Name</td>
<td>OnCustomPlay</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>A Collision sends an Event to the VFX Graph.</p>
<p><span id="page-127-0"></span><img src="_page_127_Picture_1.jpeg" alt=""></p>
<p>Rigidbody Collision</p>
<p>Any Collider making contact raises an Event (with the specified Event Name) and sends it as a message to the <strong>Visual Effect Target</strong>.</p>
<p>In this example, the <strong>Mesh Collider</strong> with a Rigidbody acts as a button. The effect only begins spawning once the player makes contact.</p>
<p>Seeing as this Event Binder responds to Collisions with a Rigidbody, you can create different forms of interactivity with it. Imagine a sphere that emits particles every time it bounces, or a force field that becomes distorted when hit with a projectile.</p>
<h4 id="-trigger-event-binder-"><strong>Trigger Event Binder</strong></h4>
<p>You can similarly add a VFX Trigger Event Binder to a GameObject with a Collider set as a trigger. This component can register certain <strong>Activation Events</strong> like <strong>OnEnter</strong>, <strong>OnExit</strong>, or <strong>OnStay</strong>. It sends an Event with the Event Name to the <strong>Target</strong> graph.</p>
<p>Use this to trigger an effect when the player, or some other GameObject, reaches a particular part of the level.</p>
<p><img src="_page_127_Picture_9.jpeg" alt=""></p>
<p>Trigger Event Binders</p>
<p><span id="page-128-0"></span><img src="_page_128_Picture_1.jpeg" alt=""></p>
<p>A Trigger Event Binder detects specific Colliders.</p>
<h4 id="-visibility-event-binder-"><strong>Visibility Event Binder</strong></h4>
<p>A Visibility Event Binder allows you to raise an Event depending on when an object becomes visible or invisible. Here, we attach it to a GameObject with some type of Renderer.</p>
<table>
<thead>
<tr>
<th>V VFX Visibility Event Binder (Script)</th>
<th></th>
<th>(2)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Script</td>
<td>VFXVisibilityEventBinder</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Target</td>
<td>Bonfire (Visual Effect)</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Event Name</td>
<td>CustomStopEvent</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Activation</td>
<td>On Became Invisible</td>
<td></td>
<td></td>
</tr>
<tr>
<td>V VFX Visibility Event Binder (Script)</td>
<td></td>
<td>(2)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Script</td>
<td>VFXVisibilityEventBinder</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Target</td>
<td>Bonfire (Visual Effect)</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>Event Name</td>
<td>CustomPlayEvent</td>
<td></td>
</tr>
</tbody>
</table>
<p>Visibility Event Binder</p>
<p>Pass the specific Event Name to the Target graph based on its <strong>Activation</strong>, either <strong>OnBecameVisible</strong> or <strong>OnBecameInvisible</strong>. This notifies the graph when the Renderer enters or leaves the Camera frustum, or toggles its Renderer on and off.</p>
<p><img src="_page_128_Picture_8.jpeg" alt=""></p>
<p>The visual effect only activates once the target becomes visible.</p>
<p><span id="page-129-0"></span><img src="_page_129_Picture_1.jpeg" alt=""></p>
<h2 id="timeline">Timeline</h2>
<p><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Timeline.html">Timeline</a> offers another way to communicate with your graphs, should you need to turn your visual effects on and off with precise timing. You can coordinate multiple layers of effects with Visual Effect Activation Tracks.</p>
<table>
<thead>
<tr>
<th>Timeline *</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Preview 14 14 14 14 14 14 14 1 1 1 0</td>
<td>C Meteorite Timeline (Timeline)<br>&gt;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>+▼</td>
<td>4 12 14 1</td>
<td>120 m 120 m 130 m 120 m 100 m 120 m 120 m 120 m 120 m 120 m 120 m 120 m 150 m 150 m 180 m 180 m 180 m 180 m 180 m 180 m 180 m 1</td>
<td></td>
</tr>
<tr>
<td>* Markers</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>A &gt; Timeline (Animator)</td>
<td>◎ 平台◎ :<br>◎</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Visual Effect) (Visual Effect)</td>
<td>0<br>平台◎ :</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>VFX_Leaves (Visual Effect)</td>
<td>平台 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =<br>の</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>Visual Effect) (Visual Effect)</td>
<td>ල<br>平台◎ :</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>VFX_StaticBird (Visual Effect)</td>
<td>平台 ◎ !<br>の</td>
<td>Visual<br>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>VFX_StaticBird (1) (Visual Effect)</td>
<td>ල<br>平台 @ :</td>
<td>Visual<br>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>VFX_Butterfly (Visual Effect)</td>
<td>の<br>平台 ◎ :</td>
<td>VisualEffectActivationClip</td>
<td>VisualEffectActivationClip</td>
</tr>
<tr>
<td>STREES (Visual Effect)</td>
<td>0<br>平台 ③ ::</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>LightFlashFX (Visual Effect)</td>
<td>の<br>平台 @ !</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Visual Effect Activation Tracks</p>
<p><img src="_page_130_Picture_0.jpeg" alt=""></p>
<table>
<thead>
<tr>
<th>Right-click in the Timeline to create a new Activation Track.</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Assign an effect to an <strong>Activation Track</strong> and then create one or more <strong>Activation Clips</strong> in the Timeline track. Each clip sends two Events; one at the beginning and one at the end.</p>
<p><img src="_page_130_Picture_4.jpeg" alt=""></p>
<p>Each Activation Clip sends two Events to its VFX Graph.</p>
<p><img src="_page_130_Picture_6.jpeg" alt=""></p>
<p>The Meteorite sample from the VFX Graph Samples project</p>
<p>The Meteorite sample demonstrates how you can use Timeline to control multiple effects that play back in concert.</p>
<p><span id="page-131-0"></span>Timeline helps organize the pieces that collectively create the sum total of the effect. Here, a separate Activation Track is used for each Subgraph and passes in Events through the Activation Clips.</p>
<p>By sliding the clips within Timeline, you can adjust the timing interactively. The custom MeteoriteControl script then invokes the Playable Director component.</p>
<table>
<thead>
<tr>
<th>Timeline®</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Preview 14 14 14 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</td>
<td></td>
<td>Meteorite Timeline (Timeline)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>+ ▼</td>
<td></td>
<td>11 2 14 1 7<br>1</td>
<td>10 ---------------------------------------------------------------------------------------------<br>160 1 1 -----<br>120     180        240          -</td>
<td>360<br>1300</td>
</tr>
<tr>
<td>* Markers</td>
<td></td>
<td>の<br>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1<br>&gt; Timeline (Animator)</td>
<td>0</td>
<td>◎<br>平台 ◎ :</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VFXG_MeteoriteMain (Visual Effect)<br>2</td>
<td>0</td>
<td>平台◎ :</td>
<td>VisualEffectActivationClip</td>
<td></td>
</tr>
<tr>
<td>VFX_Leaves (Visual Effect)</td>
<td>0</td>
<td>平台 3 1</td>
<td>/isualEffectAct</td>
<td></td>
</tr>
<tr>
<td>VFX_Leaves (1) (Visual Effect)</td>
<td>0</td>
<td>子<br>95</td>
<td>VisualEffect</td>
<td>Muted</td>
</tr>
<tr>
<td>ب VFX_StaticBird (Visual Effect)</td>
<td>0</td>
<td>-H<br>05</td>
<td>VisualEffectActiva</td>
<td>Muted</td>
</tr>
<tr>
<td>VFX_StaticBird (1) (Visual Effect)</td>
<td>O</td>
<td>大<br>95</td>
<td>VisualEffectActiva</td>
<td>Muted</td>
</tr>
<tr>
<td>VFX_Butterfly (Visual Effect)</td>
<td>0</td>
<td>*<br>ర్లాన</td>
<td>VisualEffectActi. VisualEffectA</td>
<td>Muted</td>
</tr>
<tr>
<td>STREES (Visual Effect)</td>
<td>0</td>
<td>*<br>95</td>
<td>VisualEffectActiva</td>
<td>Muted</td>
</tr>
<tr>
<td>ം LightFlashFX (Visual Effect)</td>
<td>0</td>
<td>平台 ◎ :</td>
<td>Visual Effect Activation</td>
<td></td>
</tr>
<tr>
<td>muted Activation Tracks</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Muting the Activation Tracks</p>
<p>You can also use Timeline to mute specific Visual Effect Activation Tracks, which temporarily stops them from receiving Events. This can be useful when troubleshooting.</p>
<h4 id="-event-attributes-"><strong>Event Attributes</strong></h4>
<p>Both Event Binders and Timeline Activation Clips can attach <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Events.html">Event Attribute Payloads</a> to Events. In doing so, they pass along extra information with an Event when it&#39;s invoked.</p>
<p>For instance, you might create an Event Attribute with an exposed <strong>Vector3</strong> property that notifies the graph where to instantiate the effect.</p>
<p><span id="page-132-0"></span></p>
<p>To set these Attributes in a VFX Graph, use the <strong>Set Attribute Blocks</strong> in the <strong>Spawn Contexts</strong>. You can also attach them to Events sent from C# scripts. See the Visual Effect <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/ComponentAPI.html">component API</a> for more information.</p>
<h2 id="property-binder">Property Binder</h2>
<p>Property Binders are C# behaviors that enable you to connect scene or gameplay values to the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Blackboard.html">Exposed properties</a> of the VFX Graph. You can add Property Binders through a common MonoBehaviour called the <strong>VFX Property Binder</strong>.</p>
<p>For example, a <strong>Sphere Collider Binder</strong> can automatically set the position and the radius of a <strong>Sphere Exposed Property</strong> using the values of a Sphere Collider in the scene.</p>
<p><img src="_page_132_Figure_6.jpeg" alt=""></p>
<p>The Property Binder connects a scene value to an Exposed Property.</p>
<p>Do you need a light or camera in the scene to influence your effect at runtime? Does the effect follow a Transform or a Vector3? A Property Binder can sync a number of Exposed Property types with values in your scene. Go to <strong>Add Component &gt; VFX &gt; Property Binders</strong> for the complete selection of what&#39;s available.</p>
<p>There are instances in the Visual Effect Samples that show how Property Binders can connect the Scene Hierarchy to the graph:</p>
<p>— In the Magic Lamp sample, the Property Binder ties the position of several Scene objects (P1, P2, and P3) to the graph&#39;s Blackboard properties (Pos1, Pos2, and Pos3). These <strong>Vector3 Nodes</strong> then form a <strong>Bézier spline</strong> defining the genie&#39;s overall shape. Move the P1, P2, and P3 <strong>Transforms</strong> in your scene, and the genie&#39;s smoke trail will respond in real-time.</p>
<p><img src="_page_133_Figure_4.jpeg" alt=""></p>
<p>The resulting Bézier curve drives the genie&#39;s shape</p>
<p>— In ARRadar, a <strong>PointLight Transform</strong> determines where the player&#39;s ship appears on the 3D radar screen. It syncs the glowing blip with real-time light.</p>
<p><img src="_page_133_Figure_7.jpeg" alt=""></p>
<p>The ARRadar connects a PointLight to the ship icon.</p>
<p><img src="_page_134_Picture_0.jpeg" alt=""></p>
<p>— In the Grass Wind sample, Property Binders capture the Position and Velocity of the Transform called <strong>ThirdPersonController</strong> to push the grass.</p>
<p><img src="_page_134_Picture_3.jpeg" alt=""></p>
<p>The Grass Wind sample</p>
<p>— The SpaceshipHoloTable uses a Transform called <strong>MapPosition-Controller</strong> to drive the Position of the PinScreen effect on the tabletop. Let the <strong>Animator</strong> move this through a predetermined motion or drag it around at runtime to watch the hologram come to life.</p>
<p><img src="_page_134_Picture_6.jpeg" alt=""></p>
<p>The SpaceshipHoloTable</p>
<p>These are just a few instances where Property Binders can solidify the relationship between a graph and your scene. Find <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/PropertyBinders.html">built-in Property Binders</a> for audio, input, physics, and UI, among other components.</p>
<p>Need something that doesn&#39;t exist yet? Use the <strong>UnityEngine.VFX.Utility.VFXBinderBase</strong>  class to <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/PropertyBinders.html">write your own</a> Property Binder.</p>
<h2 id="-span-id-page-135-0-span-output-events"><span id="page-135-0"></span>Output Events</h2>
<p>Just as you can leverage Events to send messages into the VFX Graph, you can similarly use them to send messages out. With <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Context-Event.html">Output Events</a>, you have the ability to obtain the Attributes of new particles from a <strong>Spawner Context</strong>. Use them with <strong>Output Event Handlers</strong> to notify your C# scripts in the scene.</p>
<table>
<thead>
<tr>
<th>4 Output Event</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>On Received Event<br>Event Name</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>Output Events</p>
<p>Create any number of behaviors that respond to your effect; shake the Camera, play back a sound, spawn a Prefab, or anything else your gameplay logic dictates.</p>
<p>In order to receive Events, <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/OutputEventHandlers.html">inherit your scripted class</a> from <strong>VFXOutputEventAbstractHandler</strong> in the <strong>UnityEngine.VFX.Utility</strong> namespace. Then, override this method:</p>
<h4 id="override-void-onvfxoutputevent-vfxeventattribute-eventattribute-">override void OnVFXOutputEvent(VFXEventAttribute eventAttribute)</h4>
<p>Unity calls OnVFXOutputEvent whenever an Event triggers, passing the Event Attributes as parameters. Look for provided implementations in the <strong>Output Event Helpers</strong>, included with the VFX Graph. Install them from the Package Manager to review the example scripts.</p>
<p>You can also revisit the Meteorite sample to see how they work within an actual graph. Attach some of these Output Event Handlers to the <strong>VFX_MeteoriteMain GameObject</strong>:</p>
<p>— <strong>Camera Shake</strong>: The <strong>VFX Output Event Cinemachine Camera Shake</strong> component rattles the Camera upon the <strong>Camera Shake Event</strong>.</p>
<table>
<thead>
<tr>
<th>V VFX Output Event Cinemachine Camera Shake (Script)</th>
<th></th>
<th>C</th>
<th>7</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Execute In Editor</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Output Event</td>
<td>Camera Shake</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cinemachine Impulse Source</td>
<td>ImpulseSource (Cinemachine Impulse Source)</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>Attribute Space</td>
<td>Local</td>
<td></td>
<td></td>
<td>&gt;</td>
</tr>
<tr>
<td>Attribute Usage<br>- position : position of the camera impulse<br>- velocity : impulse velocity</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The Camera Shake script</p>
<p>— <strong>Secondary effects</strong>: The <strong>VFX Output Event Prefab Spawn</strong> components raise the <strong>Buffer</strong> and <strong>PlankImpulse Events</strong>. A resulting shock wave passes through the grass and sends wood planks flying, courtesy of Output Event Handlers.</p>
<p><img src="_page_136_Picture_2.jpeg" alt=""></p>
<p>Output Event Handlers spawn secondary effects.</p>
<p>— <strong>Light animation</strong>: Another VFX Output Event Prefab Spawn creates the light animation upon the meteor&#39;s impact. A custom <strong>Output Event Handler Light Update</strong> script modifies the volumetric scale, brightness, and color to add more dramatic flair to the collision.</p>
<p><img src="_page_136_Picture_5.jpeg" alt=""></p>
<p>The custom Light Update Output Event Handler</p>
<p><img src="_page_137_Picture_1.jpeg" alt=""></p>
<p>A light reacts to the meteor impact effect.</p>
<p>Begin by exploring a few of these ideas. You can use the sample scripts directly without writing any code or treat them as a starting point for your own scripts. Give it some time, and soon you&#39;ll be able to roll your own Output Event Handlers for whatever your application requires.</p>
<h2 id="-span-id-page-138-0-span-pipeline-tools"><span id="page-138-0"></span>Pipeline tools</h2>
<p>Effects aren&#39;t isolated in a vacuum. Often you&#39;ll need to supply them with external data to achieve your intended look.</p>
<p>What if you want the genie to emerge from a magic lamp? Or you&#39;d like to integrate a hologram with the sci-fi spaceship? Though you can accomplish much of this with math functions and Operators, you might need the effect to interact with more complex shapes and forms.</p>
<p>For this reason, Unity provides support for a number of Data types:</p>
<ul>
<li><strong>Point Caches</strong>: Store attributes of points in space, such as Transforms, normals, colors, and UVs.</li>
<li><strong>Signed Distance Fields</strong>: Attract and collide with particles using a volumetric representation.</li>
<li><strong>Vector Fields</strong>: Push particles in 3D space after sampling the particle&#39;s position.</li>
</ul>
<p>Unity also offers some support utilities to facilitate the generation of these file formats.</p>
<h2 id="point-caches">Point Caches</h2>
<p>A <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/point-cache-in-vfx-graph.html">Point Cache</a> is an asset that stores a fixed list of <strong>Particle Attribute</strong> data, including points and their positions, normals, and colors.</p>
<p>Point Cache assets follow the open-source <a href="https://github.com/peeweek/pcache/blob/master/README.md">Point Cache specification</a> and use the <strong>.pCache</strong> file extension. Internally, Point Caches are nested <a href="https://docs.unity3d.com/Manual/class-ScriptableObject.html">ScriptableObjects</a> containing various textures</p>
<p><span id="page-139-0"></span><img src="_page_139_Picture_0.jpeg" alt=""></p>
<p>that represent the maps of Particle Attributes. They are less resource intensive than Signed Distance Fields.</p>
<p>To generate a Point Cache for use in a visual effect:</p>
<ul>
<li>Use the built-in <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/point-cache-bake-tool.html">Point Cache Bake Tool</a> via <strong>Window &gt; Visual Effects &gt; Utilities &gt; Point Cache Bake Tool</strong>.</li>
<li>Select the <strong>Houdini pCache Exporter</strong> bundled with <strong><a href="https://github.com/Unity-Technologies/VFXToolbox">VFXToolbox</a></strong>.</li>
<li>Build your own custom exporter. See the <a href="https://github.com/peeweek/pcache/blob/master/README.md">pCache README</a> for more information on the asset format and specification.</li>
</ul>
<h4 id="-point-cache-bake-tool-"><strong>Point Cache Bake Tool</strong></h4>
<p>Use the Point Cache Bake Tool to create a Point Cache from an input Mesh or a 2D Texture.</p>
<table>
<thead>
<tr>
<th>pCache Tool</th>
<th></th>
<th><br>×</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Bake Mode</td>
<td>Mesh</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mesh Baking</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mesh</td>
<td>田 Dropship_LOD01</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Distribution</td>
<td>Random Uniform Area</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Export Normals</td>
<td>V</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Export Colors</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Export UVs</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Point Count</td>
<td>4096</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Seed</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>File Format</td>
<td>Ascii</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Save to pCache file</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Mesh Statistics</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Vertices</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>45385</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Triangles</td>
<td>120192</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sub Meshes</td>
<td>5</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The Point Cache Bake Tool</p>
<p>Point Caches store lists of points generated from 3D meshes or 2D textures – but not their actual geometry. During baking, additional filtering relaxes the points in order to separate them more evenly and reduce the number of overlaps. Choose a <strong>Mesh</strong> or <strong>Texture</strong>, set an adequate <strong>Point Count</strong>, and select <strong>Save to pCache file</strong>.</p>
<p><img src="_page_139_Figure_12.jpeg" alt=""></p>
<p>A visualization of a Point Cache with different samples</p>
<p><span id="page-140-0"></span><img src="_page_140_Picture_0.jpeg" alt=""></p>
<p>Point Caches are similar to <strong><a href="https://en.wikipedia.org/wiki/PLY_(file_format">Stanford PLY</a>)</strong> files, but the .pCache file format removes the polygons and adds support for vectors. As such, they are more easily readable and writable in Python or C#.</p>
<h4 id="-using-point-caches-"><strong>Using Point Caches</strong></h4>
<p>In the VFX Graph, the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@16.0/manual/Operator-PointCache.html">Point Cache Operator</a></strong> extracts the number of particles and their Attributes from the Point Cache asset. It then exposes them as output ports in the Operator.</p>
<p>Looking at the Morphing Face sample, the Operator creates one output slot for the Point Count and separate texture slots for Attribute Maps. You can connect the outputs to other nodes, such as the <strong><a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-SetAttributeFromMap.html">Set Attribute from Map Block</a></strong>.</p>
<p><img src="_page_140_Picture_6.jpeg" alt=""></p>
<p>Using Point Caches in a VFX Graph</p>
<p><img src="_page_140_Picture_8.jpeg" alt=""></p>
<p>The Morphing Face effect applied to the Point Cache asset</p>
<p>For more information, see the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/point-cache-in-vfx-graph.html">Point Cache documentation</a>.</p>
<p>The <strong>MaskFace Point Cache</strong> drives the underlying structure of the effect.</p>
<h2 id="-span-id-page-141-0-span-signed-distance-fields"><span id="page-141-0"></span>Signed Distance Fields</h2>
<p>A <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sdf-in-vfx-graph.html">Signed Distance Field</a> (SDF) is a 3D texture representation of mesh geometry. Each texel stores the closest distance value to the surface of the mesh.</p>
<p>By convention, this distance is negative inside the mesh and positive outside of it. You can thereby place a particle at any point on the surface, inside the bounds of the geometry, or at any given distance from it.</p>
<p>While it&#39;s more resource intensive to calculate SDFs than Point Caches, they can provide additional functionality. Very detailed meshes require a high texture resolution, which typically takes up more memory.</p>
<h4 id="-using-sdfs-"><strong>Using SDFs</strong></h4>
<p>A visual effect can use SDFs to position particles, conform particles to a shape, or collide with particles. In the Magic Lamp sample, an SDF was used for the genie&#39;s body. A preview of the SDF asset looks like this:</p>
<p><img src="_page_141_Picture_7.jpeg" alt=""></p>
<p>A visual representation of a Signed Distance Field</p>
<p>Unity imports the SDF asset as a 3D texture <strong><a href="https://github.com/peeweek/VectorFieldFile/blob/master/README.md">Volume File</a></strong> (.vf). Compatible VFX Graph Blocks and Operators then make the particle system interact with the sampled points. In this example, the <strong>Conform to Signed Distance Field Block</strong> attracts the particles to the area where the genie&#39;s torso appears.</p>
<p><span id="page-142-0"></span><img src="_page_142_Figure_1.jpeg" alt=""></p>
<p>Using an SDF in a VFX Graph</p>
<p><img src="_page_142_Figure_3.jpeg" alt=""></p>
<p>The SDF Bake Tool</p>
<h4 id="-sdf-bake-tool-"><strong>SDF Bake Tool</strong></h4>
<p>You can use an external DCC tool, such as <strong>SideFX Houdini</strong>, to create SDFs. The <a href="https://github.com/Unity-Technologies/VFXToolbox">VFXToolbox</a> utility can bake Volume Files from the <strong>Houdini Volume Exporter</strong>.</p>
<p>Unity includes a utility to simplify this process: The SDF Bake Tool (<strong>Window &gt; Visual Effects &gt; Utilities &gt; SDF Bake Tool</strong>) takes an input <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/class-Mesh.html">Mesh</a> (or multiple Meshes in one Prefab) and generates a 3D texture representation of it.</p>
<p><span id="page-143-0"></span><img src="_page_143_Picture_0.jpeg" alt=""></p>
<p>You can also bake SDFs at runtime and in the Unity Editor with the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sdf-bake-tool-api.html">SDF Bake Tool API</a>. Just be aware that runtime baking is resource intensive. Best practice is to use a low-resolution SDF and only process every nth frame.</p>
<p>See <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/sdf-in-vfx-graph.html">Signed Distance Fields in the VFX Graph</a> for more details on how to generate and use SDFs, or find additional samples in <a href="https://github.com/keijiro/SdfVfxSamples">this repository.</a></p>
<h3 id="vector-fields">Vector Fields</h3>
<p>A Vector Field is a uniform grid of vectors that controls the velocity or acceleration of a particle. An arrow represents each vector. The larger the size of the vector, the faster the particles will move through it.</p>
<p><img src="_page_143_Picture_5.jpeg" alt=""></p>
<p>A 2D Vector Field (Source: <a href="https://en.wikipedia.org/wiki/Vector_field">Wikipedia</a>)</p>
<p>As with Signed Distance Fields, you can represent Vector Fields using the open-source <a href="https://github.com/peeweek/VectorFieldFile/blob/master/README.md">Volume File</a> (.vf) format or generate vector fields from the Houdini VF Exporter bundled with <a href="https://github.com/Unity-Technologies/VFXToolbox">VFXToolbox</a>. You can even write your own VF File Exporter that follows the Volume File specification.</p>
<p>In the UnityLogo scene, the particles flow as if pushed by the unseen currents of the Vector Field.</p>
<p><span id="page-144-0"></span><img src="_page_144_Picture_0.jpeg" alt=""></p>
<h4 id="-tflow-asset-store-"><strong>TFlow (Asset Store)</strong></h4>
<p><a href="https://assetstore.unity.com/packages/tools/particles-effects/tflow-201971">TFlow,</a> available on the <a href="https://assetstore.unity.com/packages/tools/particles-effects/tflow-201971#description">Unity Asset Store</a>, is a &quot;motion vector and motion blur generator that helps increase the utility and quality of your flipbooks.&quot; It can be used with both the <a href="https://youtu.be/_8LEtx-zvAM">Built-In</a>  <a href="https://youtu.be/_8LEtx-zvAM">Particle System</a> and <a href="https://youtu.be/Af4B6Gz4lzQ">VFX Graph.</a></p>
<p><img src="_page_144_Figure_4.jpeg" alt=""></p>
<p>A Vector Field drives the UnityLogo effect.</p>
<h3 id="vfxtoolbox">VFXToolbox</h3>
<p>The VFXToolbox features additional tools for Unity visual effects artists. It enables the export of .pCache and .vf files from SideFX&#39;s <strong>Houdini Point Cache Exporter</strong> and <strong>Volume Exporter</strong>.</p>
<p>Download <a href="https://github.com/Unity-Technologies/VFXToolbox">this repository on GitHub</a> and install it with the Package Manager.</p>
<h4 id="-image-sequencer-"><strong>Image Sequencer</strong></h4>
<p>Use <strong>Flipbook Texture Sheets</strong> to bake animated effects into a sprite. If you don&#39;t have the frame budget to simulate effects like smoke, fire, or explosions, saving the images as a Flipbook Texture Sheet can produce a comparable &quot;baked&quot; effect without the high cost.</p>
<p>First, use Unity or another DCC package to render an image sequence of effects into a project folder. Next, convert the individual images into a single texture sheet using the Image Sequencer. Retime and loop the images to your liking before playing them back with the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-FlipbookPlayer.html">Flipbook Player Block</a>.</p>
<p><img src="_page_145_Figure_1.jpeg" alt=""></p>
<h4 id="-span-id-page-145-0-span-be-sure-to-check-out-some-of-the-sample-flipbooks-https-blog-unity-com-technology-free-vfx-image-sequences-flipbooks-utm_source-demand-gen-utm_medium-pdf-utm_campaign-empowering-creative-teams-utm_content-advanced-visual-effects-ebook-created-with-this-tool-"><span id="page-145-0"></span>Be sure to check out some of the <a href="https://blog.unity.com/technology/free-vfx-image-sequences-flipbooks?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=empowering-creative-teams&amp;utm_content=advanced-visual-effects-ebook">sample flipbooks</a> created with this tool.</h4>
<p>An example of a flipbook texture</p>
<h2 id="digital-content-creation-tools">Digital Content Creation tools</h2>
<p>While Unity is a central tool for game development, it&#39;s not your only tool. Creating real-time visual effects can be complex, so you might look into specialized assistance from Digital Content Creation (DCC) software outside of Unity. Here are a few tools that many artists use to complement Unity and the VFX Graph:</p>
<h4 id="-sidefx-houdini-"><strong>SideFX Houdini</strong></h4>
<p>Houdini has long been an industry-standard tool for simulation and visual effects. Its procedural workflows and node-based interface facilitate the production of textures, shaders, and particles in comparatively fewer steps. Its Operator-centric structure encourages nonlinear development and covers all the major areas of 3D production.</p>
<h4 id="-autodesk-maya-"><strong>Autodesk Maya</strong></h4>
<p>Maya fortifies the foundation of many game development studios. Its relatively new Bifrost system makes it possible to create physically accurate and incredibly detailed simulations in a visual programming environment.</p>
<p><span id="page-146-0"></span><img src="_page_146_Picture_0.jpeg" alt=""></p>
<h4 id="-blender-"><strong>Blender</strong></h4>
<p>Blender is a free and open-source 3D creation suite. Its features cover all aspects of 3D production, from modeling and rigging to animation, simulation, and rendering. Blender continues to receive widespread community support, as it is cross-platform and runs equally well on Linux, Windows, and macOS.</p>
<h4 id="-adobe-photoshop-"><strong>Adobe Photoshop</strong></h4>
<p>Along with the other 3D tools discussed, you&#39;ll benefit from an image-editing software such as Adobe Photoshop. Use Photoshop to edit and create raster images in multiple layers, and support <a href="https://en.wikipedia.org/wiki/Mask_(computing">masks</a>), <a href="https://en.wikipedia.org/wiki/Alpha_compositing">alpha composites,</a> and several <a href="https://en.wikipedia.org/wiki/Color_model">color models.</a> Photoshop uses its own PSD and PSB file formats to uphold these features.</p>
<p>Of course, these are just some of the DCC tools available. As you start building your graphs, they&#39;ll help you fill in flipbook textures, meshes, or anything else to achieve your vision.</p>
<h2 id="-span-id-page-147-0-span-optimization"><span id="page-147-0"></span>Optimization</h2>
<p>After working closely with VFX Graphs, you&#39;ll likely want to reorganize and optimize them, much like how a programmer profiles code and checks its performance. Once the effect looks right, make sure it&#39;s not using excess resources before deploying to your final game or application.</p>
<h2 id="-span-id-page-148-0-span-profiling-and-debug-panels-in-vfx-graph"><span id="page-148-0"></span>Profiling and Debug panels in VFX Graph</h2>
<p>Unity 6 includes Profiling and Debug panels that provide essential information about your running visual effects. These tools can provide information such as including CPU and GPU timings, memory usage, texture usage, and various states. Use them to monitor and optimize performance for your VFX Graphs.</p>
<p>Click the debug icon in the top right of the Visual Effect Graph window. Note that these panels only work if the VFX Graph window is attached to a GameObject with a Visual Effect component.</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th><strong> </strong> **<br>0</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Toggle Debug panels</td>
</tr>
<tr>
<td>Particle</td>
<td>ങ്ങ World</td>
<td>▽ Particle System Info</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>PLAYING @ AWAKE &amp; VISIBLE<br>Alive/Capacity:<br>System CPU Update:</td>
<td>24/128<br>0.001 ms</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>GPU System time:<br>▼ GPU Memory:</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>Particle Attributes Size:</td>
<td>7.5 KB</td>
<td>Graph Debug Information</td>
<td>:</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>GPU Recorder is not supported on this platform</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▼ CPU Information</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td></td>
<td></td>
<td>Full Update</td>
<td>0.006 ms</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Evaluate Expressions<br>Smoke</td>
<td>0.001 ms<br>0.001 ms</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▼ GPU Information</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>GPU time</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>GPU memory</td>
<td>12.0 KB</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>T Texture Usage</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>Smoke<br>SimpleSmoke - 128x128 - 21.4 KB</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▼ Heatmap Parameters</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>GPU Time Threshold (ms)</td>
<td>0.1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Particle</td>
<td>電 World</td>
<td>✓ Update</td>
<td>금</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>V</td>
<td>A. POSITION O AGE<br>Execution time (GPU)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Profiling and Debug panels to optimize your VFX Graph.</p>
<h4 id="-graph-debug-information-panel-"><strong>Graph Debug Information panel</strong></h4>
<p>The <strong>Graph Debug Information</strong> panel provides the following information:</p>
<ul>
<li><strong>CPU Information:</strong> The CPU Information panel displays crucial performance metrics like the full update time for the entire graph in milliseconds, the time spent evaluating graph parameters computed on the CPU, and the update time for specific systems within the graph in milliseconds.</li>
<li><strong>GPU Information:</strong> The GPU Information panel shows the execution time of the VFX Graph on the GPU in milliseconds and its GPU memory usage.</li>
</ul>
<p><span id="page-149-0"></span><img src="_page_149_Picture_0.jpeg" alt=""></p>
<ul>
<li><strong>Texture Usage</strong>: This lists textures used, their dimensions, and memory size.</li>
<li><strong>Heatmap Parameters:</strong> Adjust the GPU time threshold to highlight expensive parts of the graph.</li>
</ul>
<p>You can also access the <strong>Rendering Debugger</strong> (URP/HDRP) and <strong>Unity Profiler</strong> from the topright vertical ellipsis (⁝) menu.</p>
<h4 id="-particle-system-info-panel-"><strong>Particle System Info panel</strong></h4>
<p>The Particle System Info panel is attached to the Initialize Context of each system. This panel provides information relative to a specific System:</p>
<ul>
<li><strong>Particle state:</strong> This shows whether the System is playing/paused, awake/asleep, and visible/culled.</li>
<li><strong>Alive/capacity:</strong> This indicates the number of particles alive and the capacity set by the user in the Initialize context. Optimizing this capacity to match the maximum number of particles alive helps save memory allocation space.</li>
</ul>
<h4 id="-context-debug-panels-"><strong>Context Debug panels</strong></h4>
<p>These panels appear when selecting a Context. Use the lock symbol on the top right to pin them onscreen. These panels can display different information per Context:</p>
<ul>
<li><strong>Spawn Context:</strong> This indicates whether the Spawner is playing or stopped.</li>
<li><strong>Initialize, Update, Output Contexts:</strong> These panels display implicitly updated attributes in the Update Context, break down GPU execution time by tasks, and list texture usage along with their dimensions and memory sizes.</li>
</ul>
<p>Keep in mind that the profiling timings in this panel are for comparison only, not precise measurements, as they&#39;re recorded in the Editor. Use them to identify bottlenecks and optimize performance.</p>
<p>Additionally, you can force runtime compilation by enabling Runtime Mode in the toolbar. This ensures that the effect uses the optimized runtime version rather than the authoring version. If you want to keep the effect fully reauthorable, uncheck this option.</p>
<p><img src="_page_149_Picture_15.jpeg" alt=""></p>
<p>Enable Runtime Mode in the toolbar.</p>
<p>Note: GPU execution timings are unavailable on Apple Silicon, and profiling panels disable instancing for the attached visual effect. To ensure accurate performance assessment, always profile on target devices using the Unity Profiler.</p>
<h2 id="-span-id-page-150-0-span-the-unity-profiler-and-frame-debugger"><span id="page-150-0"></span>The Unity Profiler and Frame Debugger</h2>
<p>The <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/Profiler.html">Unity Profiler</a> (<strong>Window &gt; Analysis &gt; Profiler</strong>) and <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/FrameDebugger.html">Frame Debugger</a> (<strong>Window &gt; Analysis &gt; Frame Debugger</strong>) can be used to optimize your graphs for stronger performance. However, the Unity Editor can affect your profiling information, leading to inaccurate results.</p>
<p>Use the <strong>Profiler Standalone Process</strong> option or create a separate build when you need to measure real-world performance. Consider the <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/OptimizingGraphicsPerformance.html">fundamentals of graphics performance</a> to maintain high frame rates, and in turn, deliver the best possible experience to your players.</p>
<p><img src="_page_150_Figure_4.jpeg" alt=""></p>
<p>The Unity Profiler</p>
<p>When examining <a href="https://docs.unity3d.com/6000.0/Documentation/Manual/RenderingStatistics.html">rendering statistics</a>, take note of the time cost per frame rather than frames per second. The fps can be misleading as a benchmark because it&#39;s nonlinear (see the graph below). If you&#39;re aiming for 60 fps, use 16 ms per frame as your frame budget (or 33 ms per frame for 30 fps).</p>
<p><img src="_page_150_Figure_7.jpeg" alt=""></p>
<p>Use the frame time as a guide for optimization.</p>
<p>The Frame Debugger shows draw call information, so you can control how the frame is constructed.</p>
<p><img src="_page_151_Figure_2.jpeg" alt=""></p>
<p>The Frame Debugger</p>
<p>In the image above, the left panel shows the sequence of draw calls and other rendering events arranged hierarchically. Meanwhile, the right panel displays the details of a selected draw call, including shader passes and textures. This helps you play &quot;frame detective&quot; and find out where Unity is spending its resources.</p>
<p>Remember to go through the usual suspects when optimizing your effects:</p>
<ul>
<li><strong>Texture size</strong>: If the asset doesn&#39;t get close to the Camera, reduce its resolution.</li>
<li><strong>Capacity</strong>: Fewer particles use less resources. Set the Capacity in the Initialize Block to cap the System&#39;s maximum number of particles.</li>
<li><strong>Visibility and lifetime</strong>: In general, if you can&#39;t see something onscreen, turn it off.</li>
</ul>
<p><span id="page-152-0"></span><img src="_page_152_Picture_0.jpeg" alt=""></p>
<h4 id="-vfx-control-debug-modes-"><strong>VFX Control Debug modes</strong></h4>
<p>The VFX Control panel includes Debug modes you can use to determine particle lifetime and capacity, which can influence performance and memory usage alike. Edit a Visual Effect instance from the Inspector, then set the Debug option to <strong>Alive</strong> or <strong>Efficiency</strong>.</p>
<p>The resulting plots will show how many particles are alive, or how that count compares to the System&#39;s set capacity. Adjust your count and capacity settings to improve your VFX Graph&#39;s efficiency.</p>
<p><img src="_page_153_Picture_0.jpeg" alt=""></p>
<ul>
<li><strong>Operators and memory</strong>: Simplify unnecessary Operators. If not visibly different, use fewer iterations.</li>
<li><strong>Flipbooks:</strong> Rather than simulate every particle, consider pre-rendering certain effects into texture flipbooks. Then, play back the animated texture wherever the full simulation isn&#39;t necessary.</li>
<li><strong>Mesh size:</strong> If your particles are Output Meshes, be sure to reduce your polygon counts.</li>
<li><strong>Excessive overdraw</strong>: If you have a number of transparent surfaces, they will consume your rendering resources. Use the Rendering Debugger (<strong>Window &gt; Analysis &gt; Rendering Debugger</strong>) to check excess overdraw and tweak your graph accordingly. Also, switch to octagon particles when possible.</li>
</ul>
<p><img src="_page_153_Picture_6.jpeg" alt=""></p>
<p>Minimize overdraw (red) to improve performance</p>
<p><span id="page-154-0"></span>When troubleshooting performance, enable or disable each Block with the checkbox at the top-right corner. This lets you do quick A/B testing to measure performance (before and after) so you can isolate part of your graph. Don&#39;t forget to restore your Blocks to their Active state once complete.</p>
<table>
<thead>
<tr>
<th></th>
<th>Spawn System</th>
<th>Start<br>Stop<br>Spawn</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Enable/disable Block ----------- Single Burst</td>
<td></td>
<td></td>
<td>V</td>
</tr>
<tr>
<td></td>
<td>Spawn Mode<br>Delay Mode</td>
<td>Constant<br>Constant</td>
<td></td>
</tr>
<tr>
<td></td>
<td>O<br>Count<br>0<br>Delay</td>
<td>0<br>0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>0<br>Set SpawnEvent Lifetime</td>
<td></td>
<td>V</td>
</tr>
<tr>
<td></td>
<td>0<br>Lifetime</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>4 SpawnEvent</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Disable/enable a Block for testing.</p>
<h2 id="bounds">Bounds</h2>
<p>The Bounds of visual effects comprise a built-in optimization based on visibility. You&#39;ve probably noticed a few settings that appear in every Initialize Context:</p>
<table>
<thead>
<tr>
<th>47</th>
<th>Initialize Particle</th>
<th></th>
<th>(LOCAL)</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Capacity<br>Bounds Setting Mode</td>
<td>128<br>Recorded</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O T Bounds</td>
<td>O</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>► Center<br>O</td>
<td>× 0</td>
<td>y O</td>
<td>z O</td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>► Size</td>
<td>× 1</td>
<td>1<br>V</td>
<td>z 1</td>
<td></td>
<td>Bounds</td>
</tr>
<tr>
<td>O▼ Bounds Padding</td>
<td>× 0</td>
<td>y O</td>
<td>z O</td>
<td>of a resident</td>
<td>settings</td>
</tr>
<tr>
<td>0<br>X</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0<br>Y</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0<br>Z</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Use the Bounds settings to define where your effect will render.</p>
<p>If the Camera can&#39;t see the Bounds, Unity culls the effect, meaning that it doesn&#39;t render. Follow these guidelines to set up each System&#39;s Bounds:</p>
<ul>
<li>If the Bounds are too large, cameras will process the visual effects even if individual particles go offscreen. This wastes resources.</li>
<li>If the Bounds are too small, Unity might cull the visual effects even if some particles are still onscreen. This can produce visible popping.</li>
</ul>
<p><span id="page-155-0"></span>By default, Unity calculates the Bounds of each System automatically, but you can change the Bounds Setting Mode to:</p>
<ul>
<li><strong>Automatic</strong>: Unity expands the Bounds to keep the effect visible. If this option is not the most efficient, use one of the other options below to optimize your Bounds.</li>
<li><strong>Manual</strong>: Use the Bounds and <strong>Bounds Padding</strong> to define a volume in the Initialize Context. This is simple yet time-consuming to set up for all of your Systems.</li>
<li><strong>Recorded</strong>: This option allows you to record the Bounds from the VFX Control panel. The Bounds, shown in red when recording, expand as you play back the effect. Press <strong>Apply Bounds</strong> to save the dimensions.</li>
</ul>
<p><img src="_page_155_Figure_5.jpeg" alt=""></p>
<p>Recording the Bounds at runtime</p>
<p>You can use Operators at runtime to calculate the Bounds for each System in <strong>Manual</strong> or <strong>Recorded</strong> mode. The Initialize Context contains a Bounds Padding input; use this Vector3 to enlarge the Bounds&#39; values.</p>
<h2 id="mesh-lod">Mesh LOD</h2>
<p>Take advantage of <strong>level of detail</strong> (LOD) if your particles are outputting meshes. Here, you can manually specify simpler meshes for distant particles.</p>
<p><strong>Particle Mesh Outputs</strong> have a <strong>Mesh Count</strong> parameter visible in the Inspector, which lets you specify up to four meshes per output. When you combine this with the LOD checkbox, you can automatically switch between meshes based on how large they appear onscreen.</p>
<p><img src="_page_155_Figure_11.jpeg" alt=""></p>
<p>Mesh Count and LOD settings in the Inspector</p>
<p>Higher resolution models can hand off to lower resolution models, depending on the screen space percentage in the LOD values of the Output context.</p>
<p><img src="_page_156_Picture_2.jpeg" alt=""></p>
<p>LOD resolutions</p>
<p>In this example, the SpaceRock_LOD0 model swaps with the smaller SpaceRock_LOD1 model when the mesh occupies less than 15% of the screen.</p>
<table>
<thead>
<tr>
<th>** Output Particle HDRP Lit Mesh @ Cocan</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Large Rocks</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Shader Graph<br>Default<br>Uv Mode<br>Opaque<br>Blend Mode<br>Use Alpha Clipping</td>
<td>None (Shader Graph Vfx Asset)<br>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>Smoothness</td>
<td>0.8</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>Thickness<br>Base Color Map<br>O<br>O<br>Mask Map<br>O<br>SpaceRock_01_Normal<br>Normal Map<br>O<br>Normal Scale<br>1<br>X<br>O<br>Mesh 0<br>出 SpaceRock_LOD0<br>Sub Mesh Mask 0<br>O<br>V<br>O<br>SpaceRock_LOD1<br>Mesh 1<br>O<br>Sub Mesh Mask 1</td>
<td>SpaceRock_01_AlbedoTransparen O<br>SpaceRock_01_MetallicSmoothne: 0<br>0<br>0<br>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>N<br>O<br>Mesh 2<br>SpaceRock_LOD2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Sub Mesh Mask 2<br>O<br>OT Lod Values<br>× 15<br>y 10<br>O<br>X<br>15<br>Y<br>O<br>10<br>Z<br>O<br>3<br>O<br>W<br>0.1</td>
<td>w 0.1<br>Z 3</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>O<br>Radius Scale<br>0.1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>LOD values</p>
<p><span id="page-157-0"></span><img src="_page_157_Picture_0.jpeg" alt=""></p>
<p>When creating a massive number of mesh particles, you won&#39;t need to render millions of polygons. This significantly cuts down the frame time.</p>
<p><img src="_page_157_Picture_3.jpeg" alt=""></p>
<p>Mesh LODs save rendering resources.</p>
<p>Check out the PlanetaryRing example in <a href="https://drive.google.com/drive/folders/169X3j528Du3gL3xOMPvqXfaC9ud5LEc4?usp=sharing">this project</a> to see the Mesh LOD firsthand.</p>
<h4 id="-mesh-count-"><strong>Mesh Count</strong></h4>
<p>You can similarly leverage the Mesh Count without LOD. In this case, we use multiple meshes to add randomness: The four different meshes for the Output Particle Lit Mesh create a variety of props scattered on the floor.</p>
<p><img src="_page_157_Picture_8.jpeg" alt=""></p>
<p>The Mesh Count randomizes mesh particles.</p>
<h2 id="particle-rendering">Particle rendering</h2>
<p>To hit your target frame rate and frame budget, consider these optimization tips when rendering particles or meshes:</p>
<ul>
<li><strong>Triangle particles</strong>: With half the geometry of quad particles, these are effective for fastmoving effects and rendering large quantities of particles.</li>
<li><strong>Simplified lighting</strong>: If you don&#39;t need the full <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/index.html">Lit HDRP</a> shader, switch to a less resourceintensive one. Customize outputs in Shader Graph to drop features you don&#39;t need for certain effects. For example, the Bonfire sample scene uses a stylized Shader Graph, which greatly simplifies the output.</li>
</ul>
<p><img src="_page_158_Picture_5.jpeg" alt=""></p>
<p>Output Particle Primitives (quad, triangle, octagon)</p>
<p>The following tips apply to HDRP only:</p>
<ul>
<li><strong>Low resolution transparency</strong>: In your <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.0/manual/Frame-Settings.html">HDRP Rendering</a> properties, enable Low Res Transparency to render your transparent particles at a lower resolution. This will boost performance by a factor of four at the expense of a little blurriness. When used judiciously, it can be nearly indistinguishable from rendering at full resolution.</li>
<li><strong>Octagon particles</strong>: Octagon particles crop the corners of quad particles. If your particle textures are transparent in the corners, this technique can reduce or prevent overdraw. Overlapping transparent areas still requires some calculation, so using octagons can save unnecessary work computing where the corners of quads intersect.</li>
</ul>
<p><img src="_page_158_Figure_10.jpeg" alt=""></p>
<p>The Bonfire scene from the Visual Effect Samples</p>
<h2 id="-span-id-page-159-0-span-advanced-features"><span id="page-159-0"></span>Advanced features</h2>
<h2 id="graphics-buffer-support">Graphics Buffer support</h2>
<p>Graphics and Compute Buffers make it easier to handle and transfer large amounts of data from C# to a VFX Graph.</p>
<p>If you are tracking multiple GameObject positions in your graph, you can make that information accessible to your simulation via scripting. Graphics Buffers can similarly replace storing data within a texture, as seen in some of the previous samples.</p>
<p>In this example, we pass the GameObjects&#39; Position and Color data from built-in Types, custom structs, and compute shaders to a VFX Graph.</p>
<p><img src="_page_159_Figure_5.jpeg" alt=""></p>
<p>Graphics Buffers send the GameObject data to the VFX Graph.</p>
<p><img src="_page_160_Picture_0.jpeg" alt=""></p>
<p>We use a script to define a Graphics Buffer and fill it with data from our GameObjects. We then pass it into the VFX Graph through its Blackboard properties.</p>
<p><img src="_page_160_Figure_3.jpeg" alt=""></p>
<p>Passing data via custom struct</p>
<p>In this more complex example, an electrifying tower can access the approaching sphere positions via Graphics Buffers. With many spheres, it becomes impractical to expose a Property for every GameObject.</p>
<p>The Blackboard has just one custom struct for use within a Graphics Buffer. The tower can potentially hit hundreds of targets, accessing their data with just a few Operators.</p>
<p><img src="_page_160_Picture_7.jpeg" alt=""></p>
<p>Graphics Buffers in action</p>
<p><span id="page-161-0"></span><img src="_page_161_Picture_0.jpeg" alt=""></p>
<p>This demonstrates how your VFX Graphs can interact within your scene; think of complex simulations like boids, fluids, hair simulation, or crowds. While using Graphics Buffers requires knowledge of the C# API, they make trading data with your GameObjects more convenient than ever.</p>
<p>Take a look at <a href="https://drive.google.com/file/d/1Ag04zfQLOnLSww6MZESjgjeWM1q75B8D/view?usp=sharing">this project</a> for other examples of how to use Graphics Buffers with the VFX Graph in Unity.</p>
<h2 id="custom-hlsl">Custom HLSL</h2>
<p>Seasoned VFX artists and developers can now take advantage of the <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CustomHLSL.html">Custom HLSL Block</a>. This feature allows you to create unique effects that may not yet be natively supported in Unity. With Custom HLSL, you could create advanced physics simulations, flocking behaviors, or real-time data visualizations.</p>
<p>Custom HLSL nodes allow you to execute custom HLSL code during particle simulation. You can use an Operator for horizontal flow or a Block for vertical flow within Contexts.</p>
<p>To be compatible with VFX Graph, a Custom HLSL Block must meet the following requirements:</p>
<ul>
<li>The return type is void.</li>
<li>There must be one parameter of type VFXAttributes with access modifier inout</li>
</ul>
<p>Create the Custom HLSL node and then either embed the HLSL code or source an HLSL text file. See this <a href="https://docs.unity3d.com/Packages/com.unity.visualeffectgraph@17.0/manual/Block-CustomHLSL.html">documentation page</a> for complete requirements.</p>
<p>Writing low-level HLSL code can be more efficient than using a complex network of VFX Graph nodes. By implementing certain calculations directly in HLSL, you can potentially improve performance, especially for computationally intensive effects.</p>
<p>Custom HLSL can be used to procedurally generate particle attributes or behaviors based on mathematical functions, noise algorithms, or other procedural techniques. This can create more organic or varied effects.</p>
<p><img src="_page_162_Picture_1.jpeg" alt=""></p>
<p>Custom HLSL can create procedural behavior.</p>
<p>This <a href="https://github.com/PaulDemeulenaere/vfx-neighborhood-grid/">project</a> demonstrates how to use neighbor search to simulate a 2D flock using a Visual Effect Graph using Custom HLSL Blocks and Graphics Buffers (see the GridManager script).</p>
<p><img src="_page_162_Figure_4.jpeg" alt=""></p>
<p>This Custom HLSL implements a neighbor search to create a flock.</p>
<h2 id="-span-id-page-163-0-span-additional-resources"><span id="page-163-0"></span>Additional resources</h2>
<p>We hope that this guide has inspired you to dive deeper into the VFX Graph and Unity&#39;s real-time visual effects toolsets. After all, our mission is to help every creator achieve their artistic vision.</p>
<p>With the VFX Graph, you&#39;re fully equipped to captivate your players with hyperrealistic simulations and stunning graphics. We can&#39;t wait to see what you create with it.</p>
<p><img src="_page_163_Picture_3.jpeg" alt=""></p>
<p>The Graphics product roadmap</p>
<p><span id="page-164-0"></span><img src="_page_164_Picture_0.jpeg" alt=""></p>
<p>Here is a collection of additional learning resources for taking on the VFX Graph:</p>
<table>
<thead>
<tr>
<th>Video tutorials</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>—</td>
<td>Create amazing VFX with the VFX Graph: This covers many of the fundamentals for<br>setting up your own VFX Graph.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>—</td>
<td>The power for artists to create: This video highlights recent updates to VFX Graph<br>features, such as Mesh LODs, Graphics Buffers, and Shader Graph integration.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>—</td>
<td>VFX Graph: Building visual elements in the Spaceship Demo: This session unpacks a<br>number of techniques used in the Spaceship Demo.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>—</td>
<td>Build a portal effect with VFX Graph: Generate a portal effect by using the VFX Graph<br>to transform a ring of particles into a more dynamic effect.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="-span-id-page-165-0-span-vfx-projects-on-github-"><span id="page-165-0"></span><strong>VFX projects on GitHub</strong></h4>
<p>Explore more possibilities with the VFX Graph, such as audio reactive effects, data visualization, and pwoint cloud or volumetric data playback. Check out these projects created by Keijiro Takahashi, senior creator advocate at Unity:</p>
<ul>
<li>Camera tracking + Lidar + VFX Graph: <a href="https://github.com/keijiro/Bibcam">Here</a> and <a href="https://github.com/keijiro/BibcamVfx">here</a></li>
<li><a href="https://github.com/keijiro/PcxEffects3">Point Cloud (pcx) + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/Akvfx">Azure Kinect + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/Rsvfx">Intel RealSense camera + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/DkvfxSketches">DepthKit + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/Dkvfx">DepthKit Volumetric video + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/4DViewsTest2">4DViews Volumetric video + Alembic + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/Abcvfx">Alembic + HAP video + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/LaspVfx">Audio Reactive + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/VfxMinisExamples">VFX Graph + Midi controllers</a></li>
<li><a href="https://github.com/keijiro/Smrvfx">Skinned Mesh sampling</a></li>
<li><a href="https://github.com/keijiro/SdfVfxSamples">SDF + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/HdrpVatExample">Vertex Animation Texture (VAT) + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/VfxGraphGraphicsBufferTest">Graphics Buffer test</a></li>
<li><a href="https://github.com/keijiro/GeoVfx">Render Geo data using Graphics Buffer + VFX Graph</a></li>
<li><a href="https://github.com/keijiro/VfxBokeh">Depth of Field particle samples</a></li>
<li><a href="https://github.com/keijiro/VfxGraphModeling">Procedural modeling using VFX Graph</a></li>
<li><a href="https://github.com/keijiro/ProcCharVfx">VFX Graph + Procedural ShaderGraph sprite generation shader</a></li>
<li><a href="https://github.com/keijiro/VfxGraphTestbed">VFX Graph test scenes</a></li>
<li><a href="https://github.com/keijiro/VfxPyro">VFX Graph interactive fireworks</a></li>
<li><a href="https://github.com/keijiro/SushiVfx">Sushi + VFX Grap</a>h</li>
</ul>
<p><img src="_page_166_Picture_0.jpeg" alt=""></p>
<p><a href="https://unity.com/es">unity.com</a></p>
</body></html>